// ========================================
// ICS-to-CVE Vulnerability Mapping Queries
// 8-Hop Attack Chain Analysis
// Sector-wide Risk Assessment
// ========================================

// ========================================
// QUERY 1: Find All Vulnerable ENERGY Assets
// ========================================
// Purpose: Identify all ENERGY sector field devices with exploitable vulnerabilities

MATCH (v:ICSVulnerability)-[:AFFECTS]->(fd:FieldDevice)
WHERE fd.sector = "ENERGY"
  AND v.remotelyExploitable = true
  AND v.cvssScore >= 7.0
  AND NOT exists((fd)-[:PATCHED_AGAINST]->(v))
RETURN
  fd.id as AssetID,
  fd.name as AssetName,
  fd.facilityId as FacilityID,
  fd.purdueLevel as PurdueLevel,
  v.cveId as CVE,
  v.cvssScore as CVSSScore,
  v.affectedProtocols as Protocols,
  v.icsAdvisory as ICSAdvisory,
  fd.criticalityScore as AssetCriticality
ORDER BY v.cvssScore DESC, fd.criticalityScore DESC
LIMIT 100;

// ========================================
// QUERY 2: 8-Hop Attack Chain Construction
// ========================================
// Purpose: Build complete attack path from initial compromise to critical infrastructure impact

MATCH path =
  (vuln:ICSVulnerability)-[:AFFECTS]->(fd:FieldDevice)
  -[:CONNECTED_TO]->(ns:NetworkSegment)
  -[:CONTAINS]->(cs:ControlSystem)
  -[:MANAGES*1..3]->(criticalAsset:FieldDevice)
  -[:CONTROLS]->(process:Process)
  -[:CRITICAL_TO]->(facility:InfrastructureFacility)
WHERE
  vuln.remotelyExploitable = true
  AND criticalAsset.criticalityScore >= 9
  AND facility.sector IN ["ENERGY", "WATER"]
RETURN
  vuln.cveId as InitialVulnerability,
  fd.id as EntryPoint,
  ns.name as LateralMovementZone,
  cs.name as EscalationTarget,
  criticalAsset.name as CriticalAsset,
  process.name as ImpactedProcess,
  facility.name as CriticalFacility,
  length(path) as HopCount,
  [node in nodes(path) | labels(node)[0]] as AttackPath
ORDER BY vuln.cvssScore DESC, criticalAsset.criticalityScore DESC
LIMIT 50;

// ========================================
// QUERY 3: Sector-Wide Vulnerability Exposure
// ========================================
// Purpose: Aggregate vulnerability statistics by CISA critical infrastructure sector

MATCH (fd:FieldDevice)
OPTIONAL MATCH (fd)<-[:AFFECTS]-(v:ICSVulnerability)
WITH
  fd.sector as Sector,
  count(DISTINCT fd) as TotalAssets,
  count(DISTINCT v) as UniqueVulnerabilities,
  avg(v.cvssScore) as AvgCVSS,
  max(v.cvssScore) as MaxCVSS,
  collect(DISTINCT v.cveId) as AllCVEs
WHERE Sector IS NOT NULL
RETURN
  Sector,
  TotalAssets,
  UniqueVulnerabilities,
  round(AvgCVSS, 2) as AvgCVSSScore,
  MaxCVSS,
  AllCVEs[0..5] as Top5CVEs,
  size(AllCVEs) as TotalCVEs
ORDER BY UniqueVulnerabilities DESC;

// ========================================
// QUERY 4: Protocol-Specific Vulnerability Landscape
// ========================================
// Purpose: Analyze vulnerability concentration by ICS protocol

MATCH (proto:ICSProtocol)<-[:EXPLOITS_PROTOCOL]-(v:ICSVulnerability)
MATCH (v)-[:AFFECTS]->(fd:FieldDevice)
WITH
  proto,
  v,
  count(fd) as AffectedAssets
RETURN
  proto.name as Protocol,
  proto.hasAuthentication as HasAuth,
  proto.hasEncryption as HasEncryption,
  proto.defaultPort as Port,
  count(DISTINCT v) as VulnerabilityCount,
  sum(AffectedAssets) as TotalExposedAssets,
  avg(v.cvssScore) as AvgCVSS,
  collect(DISTINCT v.cveId)[0..5] as SampleCVEs
ORDER BY VulnerabilityCount DESC;

// ========================================
// QUERY 5: Purdue Level Risk Assessment
// ========================================
// Purpose: Analyze vulnerability distribution across Purdue Model levels

MATCH (fd:FieldDevice)<-[:AFFECTS]-(v:ICSVulnerability)
WITH
  fd.purdueLevel as PurdueLevel,
  count(DISTINCT fd) as VulnerableDevices,
  count(DISTINCT v) as UniqueVulns,
  avg(v.cvssScore) as AvgCVSS,
  avg(fd.criticalityScore) as AvgCriticality
WHERE PurdueLevel IS NOT NULL
RETURN
  CASE PurdueLevel
    WHEN 0 THEN "L0-Process"
    WHEN 1 THEN "L1-Control"
    WHEN 2 THEN "L2-Supervisory"
    WHEN 3 THEN "L3-Operations"
    WHEN 4 THEN "L4-Enterprise"
    WHEN 5 THEN "L5-Corporate"
  END as Level,
  VulnerableDevices,
  UniqueVulns,
  round(AvgCVSS, 2) as AvgCVSSScore,
  round(AvgCriticality, 1) as AvgCriticality
ORDER BY PurdueLevel;

// ========================================
// QUERY 6: Critical Infrastructure Cascade Risk
// ========================================
// Purpose: Identify single vulnerabilities that could cascade across multiple critical facilities

MATCH (v:ICSVulnerability)-[:AFFECTS]->(fd:FieldDevice)-[:LOCATED_IN]->(facility:InfrastructureFacility)
WHERE
  facility.criticalityTier = "HIGH"
  AND v.cvssScore >= 9.0
WITH
  v,
  count(DISTINCT facility) as AffectedFacilities,
  sum(facility.populationServed) as TotalPopulationImpact,
  collect(DISTINCT facility.sector) as ImpactedSectors,
  collect(DISTINCT facility.name)[0..5] as SampleFacilities
WHERE AffectedFacilities > 1
RETURN
  v.cveId as CVE,
  v.description as Description,
  v.cvssScore as CVSS,
  AffectedFacilities,
  TotalPopulationImpact,
  ImpactedSectors,
  SampleFacilities
ORDER BY AffectedFacilities DESC, TotalPopulationImpact DESC
LIMIT 20;

// ========================================
// QUERY 7: Safety System Vulnerability Analysis
// ========================================
// Purpose: Identify vulnerabilities in safety-critical systems (SIS, ESD)

MATCH (v:ICSVulnerability)-[:AFFECTS]->(fd:FieldDevice)
WHERE
  fd.safetyLevel IN ["SIL-2", "SIL-3", "SIL-4"]
  OR fd.deviceType IN ["SIS", "ESD", "SAFETY_PLC"]
MATCH (fd)-[:PROTECTS|CONTROLS]->(process:Process)
RETURN
  fd.id as SafetyDeviceID,
  fd.name as DeviceName,
  fd.safetyLevel as SIL,
  v.cveId as CVE,
  v.cvssScore as CVSS,
  v.safetyImpact as SafetyImpact,
  process.name as ProtectedProcess,
  process.safetyClassification as ProcessSafety,
  fd.sector as Sector
ORDER BY v.cvssScore DESC, fd.safetyLevel DESC;

// ========================================
// QUERY 8: Unpatched Critical Vulnerabilities by Vendor
// ========================================
// Purpose: Track vendor-specific unpatched critical vulnerabilities

MATCH (v:ICSVulnerability)-[r:AFFECTS]->(fd:FieldDevice)
WHERE
  v.cvssScore >= 7.0
  AND r.mitigationStatus IN ["PENDING", "NONE", null]
WITH
  fd.vendor as Vendor,
  count(DISTINCT v) as UnpatchedVulns,
  count(DISTINCT fd) as AffectedDevices,
  avg(v.cvssScore) as AvgCVSS,
  collect(DISTINCT {cve: v.cveId, cvss: v.cvssScore})[0..5] as TopVulns
RETURN
  Vendor,
  UnpatchedVulns,
  AffectedDevices,
  round(AvgCVSS, 2) as AvgCVSSScore,
  TopVulns
ORDER BY UnpatchedVulns DESC, AffectedDevices DESC;

// ========================================
// QUERY 9: Network Zone Breach Impact Analysis
// ========================================
// Purpose: Analyze potential impact of network zone compromises

MATCH (ns:NetworkSegment)<-[:CONNECTED_TO]-(fd:FieldDevice)<-[:AFFECTS]-(v:ICSVulnerability)
WHERE v.remotelyExploitable = true
WITH
  ns,
  count(DISTINCT v) as ZoneVulnerabilities,
  count(DISTINCT fd) as VulnerableDevices,
  avg(v.cvssScore) as AvgVulnSeverity,
  avg(fd.criticalityScore) as AvgAssetCriticality
RETURN
  ns.name as NetworkZone,
  ns.securityZone as IEC62443Zone,
  ns.purdueLevel as PurdueLevel,
  ns.assetCount as TotalAssets,
  VulnerableDevices,
  ZoneVulnerabilities,
  round(AvgVulnSeverity, 2) as AvgVulnSeverity,
  round(AvgAssetCriticality, 1) as AvgAssetCriticality,
  CASE
    WHEN VulnerableDevices > ns.assetCount * 0.5 THEN "HIGH_RISK"
    WHEN VulnerableDevices > ns.assetCount * 0.25 THEN "MEDIUM_RISK"
    ELSE "LOW_RISK"
  END as RiskLevel
ORDER BY VulnerableDevices DESC;

// ========================================
// QUERY 10: Multi-Sector Attack Surface
// ========================================
// Purpose: Identify vulnerabilities that span multiple critical infrastructure sectors

MATCH (v:ICSVulnerability)-[:AFFECTS]->(fd:FieldDevice)
WITH
  v,
  collect(DISTINCT fd.sector) as AffectedSectors,
  count(DISTINCT fd) as TotalAssets
WHERE size(AffectedSectors) > 1
RETURN
  v.cveId as CVE,
  v.description as Description,
  v.cvssScore as CVSS,
  v.affectedVendors as Vendors,
  v.affectedProducts as Products,
  AffectedSectors,
  size(AffectedSectors) as SectorCount,
  TotalAssets
ORDER BY size(AffectedSectors) DESC, v.cvssScore DESC
LIMIT 25;

// ========================================
// QUERY 11: Exploitability vs Impact Matrix
// ========================================
// Purpose: Prioritize vulnerabilities based on exploitability and business impact

MATCH (v:ICSVulnerability)-[:AFFECTS]->(fd:FieldDevice)-[:LOCATED_IN]->(facility:InfrastructureFacility)
WITH
  v,
  CASE
    WHEN v.exploitPubliclyAvailable AND v.remotelyExploitable AND NOT v.requiresAuthentication THEN "VERY_HIGH"
    WHEN v.exploitPubliclyAvailable AND v.remotelyExploitable THEN "HIGH"
    WHEN v.remotelyExploitable THEN "MEDIUM"
    ELSE "LOW"
  END as ExploitabilityRating,
  CASE
    WHEN facility.populationServed > 100000 OR facility.criticalityTier = "HIGH" THEN "CRITICAL"
    WHEN facility.populationServed > 10000 OR facility.criticalityTier = "MEDIUM" THEN "HIGH"
    ELSE "MEDIUM"
  END as ImpactRating,
  count(DISTINCT facility) as AffectedFacilities,
  sum(facility.populationServed) as TotalPopulationImpact
RETURN
  v.cveId as CVE,
  v.cvssScore as CVSS,
  ExploitabilityRating,
  ImpactRating,
  CASE
    WHEN ExploitabilityRating IN ["VERY_HIGH", "HIGH"] AND ImpactRating = "CRITICAL" THEN "P0_IMMEDIATE"
    WHEN ExploitabilityRating IN ["VERY_HIGH", "HIGH"] OR ImpactRating = "CRITICAL" THEN "P1_HIGH"
    WHEN ExploitabilityRating = "MEDIUM" OR ImpactRating = "HIGH" THEN "P2_MEDIUM"
    ELSE "P3_LOW"
  END as PriorityLevel,
  AffectedFacilities,
  TotalPopulationImpact,
  v.patchAvailable as PatchAvailable,
  v.workaroundAvailable as WorkaroundAvailable
ORDER BY
  CASE PriorityLevel
    WHEN "P0_IMMEDIATE" THEN 0
    WHEN "P1_HIGH" THEN 1
    WHEN "P2_MEDIUM" THEN 2
    WHEN "P3_LOW" THEN 3
  END,
  v.cvssScore DESC
LIMIT 50;

// ========================================
// QUERY 12: Compliance Gap Analysis
// ========================================
// Purpose: Identify assets with vulnerabilities affecting compliance frameworks

MATCH (fd:FieldDevice)<-[:AFFECTS]-(v:ICSVulnerability)
WHERE
  v.cvssScore >= 7.0
  AND size(fd.complianceFrameworks) > 0
UNWIND fd.complianceFrameworks as Framework
WITH
  Framework,
  fd.sector as Sector,
  count(DISTINCT fd) as NonCompliantAssets,
  count(DISTINCT v) as ComplianceThreats,
  avg(v.cvssScore) as AvgCVSS
RETURN
  Framework,
  Sector,
  NonCompliantAssets,
  ComplianceThreats,
  round(AvgCVSS, 2) as AvgCVSSScore
ORDER BY Framework, NonCompliantAssets DESC;

// ========================================
// QUERY 13: Lateral Movement Path Discovery
// ========================================
// Purpose: Find potential lateral movement paths from compromised devices

MATCH path = (entry:FieldDevice)-[:CONNECTED_TO*1..4]-(target:FieldDevice)
WHERE
  exists((entry)<-[:AFFECTS]-(:ICSVulnerability))
  AND target.criticalityScore >= 8
  AND entry <> target
WITH
  entry,
  target,
  path,
  length(path) as PathLength,
  [node in nodes(path) WHERE 'NetworkSegment' IN labels(node) | node.name] as TraversedZones
RETURN
  entry.id as CompromisedDevice,
  entry.sector as Sector,
  target.id as TargetDevice,
  target.criticalityScore as TargetCriticality,
  PathLength,
  TraversedZones
ORDER BY target.criticalityScore DESC, PathLength ASC
LIMIT 100;

// ========================================
// QUERY 14: Vendor Patch Compliance Tracking
// ========================================
// Purpose: Track patch availability and deployment status by vendor

MATCH (v:ICSVulnerability)-[r:AFFECTS]->(fd:FieldDevice)
WITH
  fd.vendor as Vendor,
  count(DISTINCT v) as TotalVulnerabilities,
  sum(CASE WHEN v.patchAvailable THEN 1 ELSE 0 END) as PatchesAvailable,
  sum(CASE WHEN v.patchAvailable AND r.mitigationStatus = "PATCHED" THEN 1 ELSE 0 END) as PatchesDeployed,
  sum(CASE WHEN NOT v.patchAvailable THEN 1 ELSE 0 END) as NoPatchAvailable,
  avg(v.cvssScore) as AvgCVSS
RETURN
  Vendor,
  TotalVulnerabilities,
  PatchesAvailable,
  PatchesDeployed,
  NoPatchAvailable,
  round(toFloat(PatchesDeployed) / toFloat(PatchesAvailable) * 100, 1) as PatchDeploymentRate,
  round(AvgCVSS, 2) as AvgCVSSScore
ORDER BY TotalVulnerabilities DESC;

// ========================================
// QUERY 15: Time-Based Vulnerability Trend Analysis
// ========================================
// Purpose: Analyze vulnerability discovery trends over time

MATCH (v:ICSVulnerability)-[:AFFECTS]->(fd:FieldDevice)
WHERE v.publishedDate IS NOT NULL
WITH
  date.truncate('month', v.publishedDate) as Month,
  fd.sector as Sector,
  count(DISTINCT v) as NewVulnerabilities,
  avg(v.cvssScore) as AvgCVSS
RETURN
  toString(Month) as Month,
  Sector,
  NewVulnerabilities,
  round(AvgCVSS, 2) as AvgCVSSScore
ORDER BY Month DESC, NewVulnerabilities DESC
LIMIT 100;

// ========================================
// MAINTENANCE QUERIES
// ========================================

// Update mitigation status for patched devices
// MATCH (v:ICSVulnerability)-[r:AFFECTS]->(fd:FieldDevice)
// WHERE fd.firmwareVersion >= v.patchVersion
// SET r.mitigationStatus = "PATCHED", r.patchedDate = datetime()
// RETURN count(r) as PatchedRelationships;

// Identify stale data (not updated in 90 days)
// MATCH (fd:FieldDevice)
// WHERE duration.between(fd.updatedAt, datetime()).days > 90
// RETURN fd.id, fd.name, fd.updatedAt, duration.between(fd.updatedAt, datetime()).days as DaysSinceUpdate
// ORDER BY DaysSinceUpdate DESC;

// Calculate overall risk score for facilities
// MATCH (facility:InfrastructureFacility)<-[:LOCATED_IN]-(fd:FieldDevice)<-[:AFFECTS]-(v:ICSVulnerability)
// WITH facility,
//      sum(v.cvssScore * fd.criticalityScore) as RiskScore,
//      count(DISTINCT v) as VulnCount
// SET facility.riskScore = RiskScore / VulnCount
// RETURN facility.id, facility.name, facility.riskScore
// ORDER BY facility.riskScore DESC;
