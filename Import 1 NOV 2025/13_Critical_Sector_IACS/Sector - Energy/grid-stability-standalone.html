<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Unseen Current: Interactive Grid Stability Explorer</title>
    <!-- Import Anime.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <style>
        :root {
            --primary: #005b96;
            --secondary: #6497b1;
            --accent: #b3cde0;
            --dark: #011f4b;
            --light: #f8f9fa;
            --warning: #ff9e44;
            --danger: #d64933;
            --success: #3a7d44;
            --sidebar-width: 280px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: var(--light);
            overflow-x: hidden;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--dark));
            color: white;
            padding: 1.5rem 0;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }
        
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: var(--sidebar-width);
            height: 100vh;
            background-color: var(--dark);
            color: white;
            padding: 2rem 1.5rem;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .sidebar-toggle {
            position: fixed;
            left: var(--sidebar-width);
            top: 1rem;
            background-color: var(--primary);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 0 4px 4px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            transition: left 0.3s ease;
        }
        
        .sidebar-toggle.collapsed {
            left: 0;
        }
        
        .sidebar.collapsed {
            transform: translateX(-100%);
        }
        
        .content {
            margin-left: var(--sidebar-width);
            padding: 2rem;
            transition: margin-left 0.3s ease;
        }
        
        .content.expanded {
            margin-left: 0;
        }
        
        .visualization-option {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .visualization-option:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .visualization-option.active {
            background-color: var(--primary);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }
        
        .visualization-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .visualization-description {
            font-size: 0.85rem;
            opacity: 0.8;
        }
        
        .visualization-container {
            width: 100%;
            height: 500px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }
        
        .visualization-overlay {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 10;
            pointer-events: none;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
            background-color: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .control-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
        }
        
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #d3d3d3;
            outline: none;
            margin-bottom: 0.5rem;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }
        
        .slider-value {
            font-weight: 600;
            color: var(--primary);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #666;
        }
        
        .run-simulation {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease;
        }
        
        .run-simulation:hover {
            background-color: #004b7c;
        }
        
        .run-simulation:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .result {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }
        
        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .result-item {
            display: flex;
            flex-direction: column;
        }
        
        .result-label {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.25rem;
        }
        
        .result-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .result-value.stable {
            color: var(--success);
        }
        
        .result-value.warning {
            color: var(--warning);
        }
        
        .result-value.danger {
            color: var(--danger);
        }
        
        .result-analysis {
            background-color: #f5f5f5;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
        }
        
        .map-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 0.5rem;
            z-index: 10;
        }
        
        .map-layer-toggle {
            background: none;
            border: none;
            padding: 0.25rem 0.5rem;
            margin-right: 0.25rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        
        .map-layer-toggle.active {
            background-color: var(--primary);
            color: white;
        }

        #tooltip {
            position: absolute;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            z-index: 1000;
            max-width: 200px;
            pointer-events: none;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 0.5rem;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 91, 150, 0.1);
            border-left: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Cascade control styles */
        .cascade-controls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 10;
        }

        .cascade-controls button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
        }

        .cascade-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #cascade-time {
            background-color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: 600;
        }

        /* Form select styles */
        .form-select {
            display: block;
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            font-size: 1rem;
            font-family: inherit;
        }

        /* Icon styles */
        .icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            stroke-width: 2;
            stroke: currentColor;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* Responsive styles */
        @media (max-width: 768px) {
            :root {
                --sidebar-width: 240px;
            }
            
            .content {
                padding: 1rem;
            }
            
            .visualization-container {
                height: 350px;
            }
            
            .controls {
                flex-direction: column;
            }
        }

        .visualization-section {
            display: none;
        }

        .visualization-section.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>
    
    <div class="sidebar" id="sidebar">
        <h2>Visualizations</h2>
        <div class="visualization-option active" data-viz="frequency-response">
            <div class="visualization-title">Frequency Response Simulation</div>
            <div class="visualization-description">Simulate grid frequency response with adjustable parameters</div>
        </div>
        <div class="visualization-option" data-viz="grid-map">
            <div class="visualization-title">Power Grid Map</div>
            <div class="visualization-description">Interactive map of generation, transmission, and distribution infrastructure</div>
        </div>
        <div class="visualization-option" data-viz="inertia-impact">
            <div class="visualization-title">3D Inertia Impact</div>
            <div class="visualization-description">3D visualization showing how inertia affects system stability</div>
        </div>
        <div class="visualization-option" data-viz="blackout-cascade">
            <div class="visualization-title">Blackout Cascade Simulation</div>
            <div class="visualization-description">Simulate cascading failure mechanisms in power systems</div>
        </div>
        <div class="visualization-option" data-viz="renewable-transition">
            <div class="visualization-title">Renewable Transition</div>
            <div class="visualization-description">Visualize the impact of increasing renewable penetration on grid stability</div>
        </div>
    </div>
    
    <button class="sidebar-toggle" id="sidebar-toggle">
        ◀
    </button>
    
    <div class="content" id="content">
        <header>
            <h1>The Unseen Current: Interactive Grid Stability Explorer</h1>
            <p>By J. McKenney | May 7, 2025</p>
        </header>
        
        <div class="alert" style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 1rem 0;">
            <strong>Recent Event:</strong> On April 28, 2025, Spain and Portugal experienced their worst blackout in history, affecting 60 million people for up to 10 hours. This interactive tool helps visualize the grid stability challenges that led to this event.
        </div>
        
        <!-- Frequency Response Simulation -->
        <div id="frequency-response" class="visualization-section active">
            <h2>Frequency Response Simulation</h2>
            <p>Adjust the parameters to see how different factors affect the grid's response to a disturbance. This simulation models the Rate of Change of Frequency (RoCoF) and frequency nadir based on system inertia, disturbance size, and Grid-Forming (GFM) inverter penetration.</p>
            
            <div class="controls">
                <div class="control-group">
                    <label class="control-label" for="inertia">System Inertia (GW·s)</label>
                    <div class="slider-container">
                        <input type="range" min="2000" max="15000" value="8000" class="slider" id="inertia">
                        <div class="slider-labels">
                            <span>Low</span>
                            <span class="slider-value" id="inertia-value">8000</span>
                            <span>High</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="disturbance">Disturbance Size (MW)</label>
                    <div class="slider-container">
                        <input type="range" min="100" max="2000" value="500" class="slider" id="disturbance">
                        <div class="slider-labels">
                            <span>Small</span>
                            <span class="slider-value" id="disturbance-value">500</span>
                            <span>Large</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="gfm-penetration">Grid-Forming Penetration (%)</label>
                    <div class="slider-container">
                        <input type="range" min="0" max="50" value="10" class="slider" id="gfm-penetration">
                        <div class="slider-labels">
                            <span>None</span>
                            <span class="slider-value" id="gfm-value">10</span>
                            <span>High</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <button class="run-simulation" id="run-simulation">Trigger Disturbance Event</button>
            
            <div class="result" id="simulation-results" style="margin-top: 1.5rem;">
                <div class="result-title">Simulation Results</div>
                <div class="result-grid">
                    <div class="result-item">
                        <div class="result-label">Rate of Change of Frequency (RoCoF)</div>
                        <div class="result-value" id="rocof-result">0.375 Hz/s</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Frequency Nadir</div>
                        <div class="result-value" id="nadir-result">49.85 Hz</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Stability Assessment</div>
                        <div class="result-value stable" id="stability-result">Stable</div>
                    </div>
                </div>
                <div class="result-analysis" id="result-analysis">
                    This system has adequate inertia and would likely remain stable following this disturbance. The relatively low RoCoF allows protection systems and generator controls to respond effectively.
                </div>
            </div>
            
            <div class="visualization-container">
                <div id="frequency-chart"></div>
                <div class="loading-overlay" id="freq-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- Power Grid Map -->
        <div id="grid-map" class="visualization-section">
            <h2>Power Grid Infrastructure Map</h2>
            <p>Interactive map showing generation sources, transmission network, and substations. Toggle layers and hover over elements to see details. Recent events like the 2025 Spain-Portugal blackout highlight the vulnerability of interconnected grids.</p>
            
            <div class="visualization-container">
                <div id="map-container"></div>
                <div class="map-controls">
                    <button class="map-layer-toggle active" data-layer="generation">Generation</button>
                    <button class="map-layer-toggle active" data-layer="transmission">Transmission</button>
                    <button class="map-layer-toggle active" data-layer="substations">Substations</button>
                    <button class="map-layer-toggle" data-layer="renewables">Renewables</button>
                    <button class="map-layer-toggle" data-layer="stability">Stability Risk</button>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>Hydroelectric</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>Thermal Generation</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <span>Renewables</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9b59b6;"></div>
                        <span>Nuclear</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f1c40f;"></div>
                        <span>Interconnection Point</span>
                    </div>
                </div>
                <div class="loading-overlay" id="map-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- 3D Inertia Impact -->
        <div id="inertia-impact" class="visualization-section">
            <h2>3D Inertia Impact Visualization</h2>
            <p>This 3D visualization shows how system inertia influences grid stability. The virtual grid responds to disturbances differently based on available inertia, illustrating the "shock absorber" effect of synchronous generators.</p>
            
            <div class="controls">
                <div class="control-group">
                    <label class="control-label" for="inertia-3d">System Inertia</label>
                    <div class="slider-container">
                        <input type="range" min="10" max="100" value="60" class="slider" id="inertia-3d">
                        <div class="slider-labels">
                            <span>Low</span>
                            <span class="slider-value" id="inertia-3d-value">60%</span>
                            <span>High</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="generator-mix">Generator Mix</label>
                    <div class="slider-container">
                        <input type="range" min="0" max="100" value="40" class="slider" id="generator-mix">
                        <div class="slider-labels">
                            <span>Conventional</span>
                            <span class="slider-value" id="generator-mix-value">40% IBR</span>
                            <span>IBR</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <button class="run-simulation" id="run-3d-simulation">Apply Disturbance</button>
            
            <div class="visualization-container">
                <div id="three-container"></div>
                <div class="visualization-overlay">
                    <span id="three-info">Rotate model with mouse drag. Zoom with scroll.</span>
                </div>
                <div class="loading-overlay" id="three-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- Blackout Cascade Simulation -->
        <div id="blackout-cascade" class="visualization-section">
            <h2>Blackout Cascade Simulation</h2>
            <p>Visualize how a single fault can lead to a cascading failure across the power system. This simulation is inspired by real-world events like the 2003 US Northeast Blackout and the 2025 Iberian Peninsula Blackout.</p>
            
            <div class="controls">
                <div class="control-group">
                    <label class="control-label" for="initial-fault">Initial Fault Type</label>
                    <select id="initial-fault" class="form-select">
                        <option value="line-trip">Transmission Line Trip</option>
                        <option value="generator-loss">Generation Loss</option>
                        <option value="oscillation">Inter-Area Oscillation</option>
                        <option value="multiple">Multiple Contingency</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="system-loading">System Loading</label>
                    <div class="slider-container">
                        <input type="range" min="60" max="95" value="80" class="slider" id="system-loading">
                        <div class="slider-labels">
                            <span>Light</span>
                            <span class="slider-value" id="system-loading-value">80%</span>
                            <span>Heavy</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="protection-response">Protection Response</label>
                    <select id="protection-response" class="form-select">
                        <option value="optimal">Optimal</option>
                        <option value="normal" selected>Normal</option>
                        <option value="mis-operation">With Mis-operations</option>
                    </select>
                </div>
            </div>
            
            <button class="run-simulation" id="run-cascade">Start Cascade Simulation</button>
            
            <div class="visualization-container">
                <div id="cascade-container"></div>
                <div class="cascade-controls">
                    <button id="pause-cascade" disabled>⏸ Pause</button>
                    <button id="restart-cascade" disabled>⟳ Restart</button>
                    <div id="cascade-time">Time: 0s</div>
                </div>
                <div class="loading-overlay" id="cascade-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- Renewable Transition -->
        <div id="renewable-transition" class="visualization-section">
            <h2>Renewable Energy Transition Impact</h2>
            <p>Explore how increasing renewable penetration affects grid stability over time. This visualization shows the relationship between renewable adoption, system inertia, and stability metrics.</p>
            
            <div class="controls">
                <div class="control-group">
                    <label class="control-label" for="year-slider">Projection Year</label>
                    <div class="slider-container">
                        <input type="range" min="2020" max="2050" value="2025" step="5" class="slider" id="year-slider">
                        <div class="slider-labels">
                            <span>2020</span>
                            <span class="slider-value" id="year-value">2025</span>
                            <span>2050</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="scenario">Transition Scenario</label>
                    <select id="scenario" class="form-select">
                        <option value="moderate">Moderate Transition</option>
                        <option value="accelerated">Accelerated Transition</option>
                        <option value="gfm">High Grid-Forming Adoption</option>
                        <option value="storage">High Storage Integration</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="region">Region</label>
                    <select id="region" class="form-select">
                        <option value="europe">Europe</option>
                        <option value="north-america">North America</option>
                        <option value="australia">Australia</option>
                        <option value="global">Global Average</option>
                    </select>
                </div>
            </div>
            
            <button class="run-simulation" id="update-transition">Update Projection</button>
            
            <div class="visualization-container">
                <div id="transition-container"></div>
                <div class="loading-overlay" id="transition-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Three.js with ES modules approach -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Make THREE available globally for our application
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;

        // Initialize Three.js scene after import is complete
        document.addEventListener('DOMContentLoaded', function() {
            // This will only run after THREE.js is fully loaded
            if (document.getElementById('inertia-impact').classList.contains('active')) {
                initializeThreeJsVisualization();
            }
        });
    </script>

    <script>
        // DOM elements
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const content = document.getElementById('content');
        const vizOptions = document.querySelectorAll('.visualization-option');
        const vizSections = document.querySelectorAll('.visualization-section');
        const tooltip = document.getElementById('tooltip');
        
        // Sidebar toggle
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
            sidebarToggle.classList.toggle('collapsed');
            sidebarToggle.textContent = sidebar.classList.contains('collapsed') ? '▶' : '◀';
            content.classList.toggle('expanded');
        });
        
        // Visualization selection
        vizOptions.forEach(option => {
            option.addEventListener('click', () => {
                // Update active class
                vizOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                
                // Show selected visualization section
                const vizId = option.getAttribute('data-viz');
                vizSections.forEach(section => {
                    section.style.display = section.id === vizId ? 'block' : 'none';
                    section.classList.toggle('active', section.id === vizId);
                });
                
                // Initialize the selected visualization
                initializeVisualization(vizId);
            });
        });
        
        // Tooltip functionality
        document.addEventListener('mousemove', (e) => {
            tooltip.style.left = (e.pageX + 15) + 'px';
            tooltip.style.top = (e.pageY + 15) + 'px';
        });
        
        function showTooltip(content) {
            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Initialize visualization based on selection
        function initializeVisualization(vizId) {
            switch(vizId) {
                case 'frequency-response':
                    // Already initialized
                    break;
                case 'grid-map':
                    initializeGridMap();
                    break;
                case 'inertia-impact':
                    initializeThreeJsVisualization();
                    break;
                case 'blackout-cascade':
                    initializeCascadeSimulation();
                    break;
                case 'renewable-transition':
                    initializeRenewableTransition();
                    break;
            }
        }
        
        // ======== FREQUENCY RESPONSE SIMULATION ========
        const inertiaSlider = document.getElementById('inertia');
        const inertiaValue = document.getElementById('inertia-value');
        const disturbanceSlider = document.getElementById('disturbance');
        const disturbanceValue = document.getElementById('disturbance-value');
        const gfmSlider = document.getElementById('gfm-penetration');
        const gfmValue = document.getElementById('gfm-value');
        const runSimulation = document.getElementById('run-simulation');
        const rocofResult = document.getElementById('rocof-result');
        const nadirResult = document.getElementById('nadir-result');
        const stabilityResult = document.getElementById('stability-result');
        const resultAnalysis = document.getElementById('result-analysis');
        const freqLoading = document.getElementById('freq-loading');
        
        // Update slider values
        inertiaSlider.addEventListener('input', () => {
            inertiaValue.textContent = inertiaSlider.value;
            updateSimulationResults();
        });
        
        disturbanceSlider.addEventListener('input', () => {
            disturbanceValue.textContent = disturbanceSlider.value;
            updateSimulationResults();
        });
        
        gfmSlider.addEventListener('input', () => {
            gfmValue.textContent = gfmSlider.value;
            updateSimulationResults();
        });
        
        // Calculate simulation results based on slider values
        function updateSimulationResults() {
            const inertia = parseInt(inertiaSlider.value);
            const disturbance = parseInt(disturbanceSlider.value);
            const gfmPenetration = parseInt(gfmSlider.value);
            
            // Calculate RoCoF: disturbance / (2 * inertia / 1000) * (1 - (gfmPenetration * 0.015))
            const rocof = (disturbance / (2 * inertia / 1000)) * (1 - (gfmPenetration * 0.015));
            const rocofFormatted = rocof.toFixed(3);
            
            // Calculate Nadir: 50 - (disturbance / (inertia / 100)) + (gfmPenetration * 0.005)
            const nadir = 50 - (disturbance / (inertia / 100)) + (gfmPenetration * 0.005);
            const nadirFormatted = nadir.toFixed(2);
            
            // Update result values
            rocofResult.textContent = rocofFormatted + ' Hz/s';
            nadirResult.textContent = nadirFormatted + ' Hz';
            
            // Update stability assessment
            let stabilityClass, stabilityText, analysisText;
            
            if (rocof > 1.0) {
                stabilityClass = 'danger';
                stabilityText = 'Unstable';
                analysisText = 'This system has critically low inertia for the given disturbance. The high RoCoF would likely trigger protective relays, potentially leading to a cascading failure.';
            } else if (rocof > 0.5) {
                stabilityClass = 'warning';
                stabilityText = 'Marginally Stable';
                analysisText = 'This system is marginally stable. The moderate RoCoF could challenge some protection systems. Additional control measures may be needed to ensure reliable operation.';
            } else {
                stabilityClass = 'stable';
                stabilityText = 'Stable';
                analysisText = 'This system has adequate inertia and would likely remain stable following this disturbance. The relatively low RoCoF allows protection systems and generator controls to respond effectively.';
            }
            
            stabilityResult.textContent = stabilityText;
            stabilityResult.className = 'result-value ' + stabilityClass;
            resultAnalysis.textContent = analysisText;
            
            return { rocof, nadir, stabilityClass };
        }
        
        // Initial calculation
        updateSimulationResults();
        
        // Run simulation button
        runSimulation.addEventListener('click', () => {
            freqLoading.style.display = 'flex';
            runSimulation.disabled = true;
            
            // Simulate calculation delay
            setTimeout(() => {
                const results = updateSimulationResults();
                renderFrequencyChart(results);
                runSimulation.disabled = false;
                freqLoading.style.display = 'none';
            }, 1000);
        });
        
        // Render frequency chart using SVG
        function renderFrequencyChart(results) {
            const chartContainer = document.getElementById('frequency-chart');
            chartContainer.innerHTML = '';
            
            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', '0 0 1000 400');
            chartContainer.appendChild(svg);
            
            // Create grid lines
            for (let i = 0; i <= 10; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '50');
                line.setAttribute('y1', 50 + i * 30);
                line.setAttribute('x2', '950');
                line.setAttribute('y2', 50 + i * 30);
                line.setAttribute('stroke', '#e0e0e0');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
            }
            
            for (let i = 0; i <= 20; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 50 + i * 45);
                line.setAttribute('y1', '50');
                line.setAttribute('x2', 50 + i * 45);
                line.setAttribute('y2', '350');
                line.setAttribute('stroke', '#e0e0e0');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
            }
            
            // Create axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', '50');
            xAxis.setAttribute('y1', '350');
            xAxis.setAttribute('x2', '950');
            xAxis.setAttribute('y2', '350');
            xAxis.setAttribute('stroke', '#333');
            xAxis.setAttribute('stroke-width', '2');
            svg.appendChild(xAxis);
            
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', '50');
            yAxis.setAttribute('y1', '50');
            yAxis.setAttribute('x2', '50');
            yAxis.setAttribute('y2', '350');
            yAxis.setAttribute('stroke', '#333');
            yAxis.setAttribute('stroke-width', '2');
            svg.appendChild(yAxis);
            
            // Add axis labels
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', '500');
            xLabel.setAttribute('y', '390');
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('font-size', '14');
            xLabel.textContent = 'Time (seconds)';
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', '-200');
            yLabel.setAttribute('y', '20');
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('font-size', '14');
            yLabel.setAttribute('transform', 'rotate(-90)');
            yLabel.textContent = 'Frequency (Hz)';
            svg.appendChild(yLabel);
            
            // Add tick marks and labels
            for (let i = 0; i <= 20; i += 5) {
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', 50 + i * 45);
                tick.setAttribute('y1', '350');
                tick.setAttribute('x2', 50 + i * 45);
                tick.setAttribute('y2', '355');
                tick.setAttribute('stroke', '#333');
                tick.setAttribute('stroke-width', '2');
                svg.appendChild(tick);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', 50 + i * 45);
                label.setAttribute('y', '370');
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.textContent = i;
                svg.appendChild(label);
            }
            
            // Y-axis ticks and labels (49.0 to 50.5 Hz)
            const freqRange = [49.0, 49.2, 49.4, 49.6, 49.8, 50.0, 50.2, 50.4];
            freqRange.forEach((freq, i) => {
                const y = 350 - ((freq - 49.0) * 300 / 1.4);
                
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', '45');
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', '50');
                tick.setAttribute('y2', y);
                tick.setAttribute('stroke', '#333');
                tick.setAttribute('stroke-width', '2');
                svg.appendChild(tick);
                
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', '40');
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '12');
                label.textContent = freq.toFixed(1);
                svg.appendChild(label);
            });
            
            // Reference line at 50 Hz
            const refLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            refLine.setAttribute('x1', '50');
            refLine.setAttribute('y1', '136');
            refLine.setAttribute('x2', '950');
            refLine.setAttribute('y2', '136');
            refLine.setAttribute('stroke', '#999');
            refLine.setAttribute('stroke-dasharray', '5,5');
            refLine.setAttribute('stroke-width', '1');
            svg.appendChild(refLine);
            
            // Generate frequency data points based on simulation parameters
            const inertia = parseInt(inertiaSlider.value);
            const disturbance = parseInt(disturbanceSlider.value);
            const gfmPenetration = parseInt(gfmSlider.value);
            
            const points = [];
            points.push({ x: 50, y: 136 }); // 50 Hz starting point
            
            const rocof = results.rocof;
            const nadir = results.nadir;
            const nadirTime = 3 + (inertia / 5000); // Time to reach nadir depends on inertia
            
            // Calculate y position of nadir (convert frequency to y coordinate)
            const nadirY = 350 - ((nadir - 49.0) * 300 / 1.4);
            
            // Initial frequency drop
            for (let t = 0.1; t <= nadirTime; t += 0.1) {
                // Non-linear curve to nadir
                const progress = t / nadirTime;
                const easedProgress = 1 - Math.pow(1 - progress, 3); // Cubic ease-out
                const freq = 50 - (50 - nadir) * easedProgress;
                const x = 50 + t * 45;
                const y = 350 - ((freq - 49.0) * 300 / 1.4);
                points.push({ x, y });
            }
            
            // Recovery and oscillations
            const dampingFactor = 0.7 + (gfmPenetration / 100); // Higher GFM = better damping
            const oscillationFreq = 0.2 + (0.1 * (15000 - inertia) / 13000); // Higher oscillation frequency with less inertia
            
            for (let t = nadirTime + 0.1; t <= 20; t += 0.1) {
                const timeSinceNadir = t - nadirTime;
                const amplitude = (50 - nadir) * Math.exp(-dampingFactor * timeSinceNadir);
                const oscillation = amplitude * Math.sin(2 * Math.PI * oscillationFreq * timeSinceNadir);
                const freq = 50 - oscillation;
                const x = 50 + t * 45;
                const y = 350 - ((freq - 49.0) * 300 / 1.4);
                points.push({ x, y });
            }
            
            // Create path for frequency curve
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let d = `M${points[0].x},${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                d += ` L${points[i].x},${points[i].y}`;
            }
            
            path.setAttribute('d', d);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', results.stabilityClass === 'danger' ? '#d64933' : 
                             results.stabilityClass === 'warning' ? '#ff9e44' : '#3a7d44');
            path.setAttribute('stroke-width', '3');
            svg.appendChild(path);
            
            // Animate the path drawing
            path.setAttribute('stroke-dasharray', path.getTotalLength());
            path.setAttribute('stroke-dashoffset', path.getTotalLength());
            
            anime({
                targets: path,
                strokeDashoffset: 0,
                duration: 2000,
                easing: 'easeInOutSine'
            });
            
            // Add point for nadir with label
            const nadirPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            nadirPoint.setAttribute('cx', 50 + nadirTime * 45);
            nadirPoint.setAttribute('cy', nadirY);
            nadirPoint.setAttribute('r', '5');
            nadirPoint.setAttribute('fill', results.stabilityClass === 'danger' ? '#d64933' : 
                                    results.stabilityClass === 'warning' ? '#ff9e44' : '#3a7d44');
            
            // Animate the nadir point
            nadirPoint.style.opacity = 0;
            svg.appendChild(nadirPoint);
            
            anime({
                targets: nadirPoint,
                r: [0, 5],
                opacity: [0, 1],
                delay: nadirTime * 100,
                duration: 500,
                easing: 'easeOutElastic'
            });
            
            // Add nadir label
            const nadirLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            nadirLabel.setAttribute('x', 50 + nadirTime * 45 + 10);
            nadirLabel.setAttribute('y', nadirY - 10);
            nadirLabel.setAttribute('font-size', '12');
            nadirLabel.setAttribute('fill', results.stabilityClass === 'danger' ? '#d64933' : 
                                    results.stabilityClass === 'warning' ? '#ff9e44' : '#3a7d44');
            nadirLabel.textContent = `Nadir: ${nadir.toFixed(2)} Hz`;
            nadirLabel.style.opacity = 0;
            svg.appendChild(nadirLabel);
            
            // Animate the nadir label
            anime({
                targets: nadirLabel,
                opacity: [0, 1],
                translateX: [10, 0],
                delay: nadirTime * 100 + 200,
                duration: 500,
                easing: 'easeOutQuad'
            });
            
            // Add RoCoF indicator (slope line)
            const rocofarrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            rocofarrow.setAttribute('x1', '100');
            rocofarrow.setAttribute('y1', '136');
            rocofarrow.setAttribute('x2', '190');
            rocofarrow.setAttribute('y2', 136 + rocof * 45);
            rocofarrow.setAttribute('stroke', results.stabilityClass === 'danger' ? '#d64933' : 
                                    results.stabilityClass === 'warning' ? '#ff9e44' : '#3a7d44');
            rocofarrow.setAttribute('stroke-width', '2');
            rocofarrow.setAttribute('marker-end', 'url(#arrow)');
            rocofarrow.style.opacity = 0;
            
            // Create arrowhead marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrow');
            marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '5');
            marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6');
            marker.setAttribute('orient', 'auto');
            
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
            arrowPath.setAttribute('fill', results.stabilityClass === 'danger' ? '#d64933' : 
                                    results.stabilityClass === 'warning' ? '#ff9e44' : '#3a7d44');
            marker.appendChild(arrowPath);
            defs.appendChild(marker);
            svg.appendChild(defs);
            svg.appendChild(rocofarrow);
            
            // Animate the RoCoF arrow
            anime({
                targets: rocofarrow,
                opacity: [0, 1],
                delay: 700,
                duration: 500,
                easing: 'easeOutQuad'
            });
            
            // Add RoCoF label
            const rocofLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            rocofLabel.setAttribute('x', '145');
            rocofLabel.setAttribute('y', '115');
            rocofLabel.setAttribute('font-size', '12');
            rocofLabel.setAttribute('text-anchor', 'middle');
            rocofLabel.setAttribute('fill', results.stabilityClass === 'danger' ? '#d64933' : 
                                    results.stabilityClass === 'warning' ? '#ff9e44' : '#3a7d44');
            rocofLabel.textContent = `RoCoF: ${rocof.toFixed(2)} Hz/s`;
            rocofLabel.style.opacity = 0;
            svg.appendChild(rocofLabel);
            
            // Animate the RoCoF label
            anime({
                targets: rocofLabel,
                opacity: [0, 1],
                translateY: [10, 0],
                delay: 700,
                duration: 500,
                easing: 'easeOutQuad'
            });
        }

        // ======== 3D GRID VISUALIZATION WITH THREE.JS ========
        let threeScene, threeRenderer, threeCamera, threeControls;
        let gridMesh, generatorObjects = [], gridLines = [];
        let animationMixer, generatorAnimations = [];
        let disturbanceEffect;
        let threeAnimationFrame;

        function initializeThreeJsVisualization() {
            const container = document.getElementById('three-container');
            if (!container) return;

            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                console.error('Three.js not loaded');
                // Show error message in container
                container.innerHTML = '<div style="color: red; padding: 20px;">Three.js not loaded. Please check your internet connection.</div>';
                return;
            }

            // Clear previous scene if any
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            // Cancel any previous animation frame
            if (threeAnimationFrame) {
                cancelAnimationFrame(threeAnimationFrame);
            }

            // Setup scene
            threeScene = new THREE.Scene();
            threeScene.background = new THREE.Color(0xf0f0f0);

            // Setup camera
            threeCamera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            threeCamera.position.set(15, 10, 15);
            threeCamera.lookAt(0, 0, 0);

            // Setup renderer
            threeRenderer = new THREE.WebGLRenderer({ antialias: true });
            threeRenderer.setSize(container.clientWidth, container.clientHeight);
            threeRenderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(threeRenderer.domElement);

            // Setup orbit controls if available
            if (typeof OrbitControls !== 'undefined') {
                threeControls = new OrbitControls(threeCamera, threeRenderer.domElement);
                threeControls.enableDamping = true;
                threeControls.dampingFactor = 0.05;
            }

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            threeScene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            threeScene.add(directionalLight);

            // Create grid base
            const gridGeometry = new THREE.PlaneGeometry(20, 20);
            const gridMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
            gridMesh.rotation.x = -Math.PI / 2;
            gridMesh.position.y = -0.1;
            threeScene.add(gridMesh);

            // Add grid lines
            createGridLines();

            // Add generators and transmission nodes
            createPowerSystemObjects();

            // Setup animation mixer
            animationMixer = new THREE.AnimationMixer(threeScene);

            // Handle window resize
            window.addEventListener('resize', onThreeWindowResize);

            // Animation loop
            function animate() {
                threeAnimationFrame = requestAnimationFrame(animate);
                
                // Update controls if available
                if (threeControls) {
                    threeControls.update();
                }
                
                // Update animations
                const delta = 0.016; // Approximately 60fps
                if (animationMixer) animationMixer.update(delta);
                
                // Update generator animations
                generatorObjects.forEach(obj => {
                    if (obj.userData && obj.userData.animate) {
                        obj.userData.animate(delta);
                    }
                });
                
                threeRenderer.render(threeScene, threeCamera);
            }

            animate();
        }

        function createGridLines() {
            // Create grid lines
            const lineSize = 10;
            const divisions = 10;
            const step = lineSize * 2 / divisions;
            
            const linesMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
            
            // Create grid lines
            for (let i = -lineSize; i <= lineSize; i += step) {
                // X axis lines
                const xLineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(i, 0, -lineSize),
                    new THREE.Vector3(i, 0, lineSize)
                ]);
                const xLine = new THREE.Line(xLineGeometry, linesMaterial);
                threeScene.add(xLine);
                gridLines.push(xLine);
                
                // Z axis lines
                const zLineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-lineSize, 0, i),
                    new THREE.Vector3(lineSize, 0, i)
                ]);
                const zLine = new THREE.Line(zLineGeometry, linesMaterial);
                threeScene.add(zLine);
                gridLines.push(zLine);
            }
        }

        function createPowerSystemObjects() {
            // Clear previous objects
            generatorObjects.forEach(obj => {
                if (threeScene) threeScene.remove(obj);
            });
            generatorObjects = [];
            
            // Get parameters from sliders
            const inertiaValue = document.getElementById('inertia-3d').value;
            const generatorMix = document.getElementById('generator-mix').value;
            
            // Calculate numbers of each type
            const totalGenerators = 15;
            const ibrCount = Math.round(totalGenerators * generatorMix / 100);
            const conventionalCount = totalGenerators - ibrCount;
            
            // Conventional generators - rotating machines (cylinders with animation)
            for (let i = 0; i < conventionalCount; i++) {
                const angle = (i / conventionalCount) * Math.PI * 2;
                const radius = 6 + Math.random() * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.6, 0.8, 0.3, 16);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, 0, z);
                
                // Generator
                const genGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
                const genMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
                const generator = new THREE.Mesh(genGeometry, genMaterial);
                generator.position.set(0, 0.65, 0);
                base.add(generator);
                
                // Rotor (visible spinning part)
                const rotorGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.2);
                const rotorMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
                const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                rotor.position.set(0, 0, 0);
                generator.add(rotor);
                
                threeScene.add(base);
                generatorObjects.push(base);
                
                // Animation for spinning
                const rotationSpeed = 1 + Math.random() * 0.5; // Varies slightly between generators
                
                // Animation function
                base.userData = {
                    animate: (delta) => {
                        rotor.rotation.y += rotationSpeed * delta;
                    }
                };
            }
            
            // IBRs (solar/wind) (boxes with no rotation)
            for (let i = 0; i < ibrCount; i++) {
                const angle = (i / ibrCount) * Math.PI * 2;
                const radius = 6 + Math.random() * 2;
                const x = Math.cos(angle + Math.PI) * radius; // Position on opposite side
                const z = Math.sin(angle + Math.PI) * radius;
                
                // Base
                const baseGeometry = new THREE.BoxGeometry(1.2, 0.3, 1.2);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, 0, z);
                
                // IBR unit
                const type = Math.random() > 0.5 ? 'solar' : 'wind';
                
                if (type === 'solar') {
                    // Solar panel
                    const panelGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                    const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    panel.position.set(0, 0.2, 0);
                    // Tilt the panel
                    panel.rotation.x = -Math.PI / 6;
                    base.add(panel);
                } else {
                    // Wind turbine
                    const towerGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 8);
                    const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.set(0, 0.9, 0);
                    base.add(tower);
                    
                    // Nacelle
                    const nacelleGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.5);
                    const nacelleMaterial = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
                    const nacelle = new THREE.Mesh(nacelleGeometry, nacelleMaterial);
                    nacelle.position.set(0, 1.7, 0);
                    base.add(nacelle);
                    
                    // Blades
                    const bladesGroup = new THREE.Group();
                    bladesGroup.position.set(0, 1.7, 0.25);
                    
                    for (let j = 0; j < 3; j++) {
                        const bladeGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.02);
                        const bladeMaterial = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.set(0, 0.3, 0);
                        blade.rotation.z = (Math.PI * 2 / 3) * j;
                        bladesGroup.add(blade);
                    }
                    
                    base.add(bladesGroup);
                    
                    // Animation for spinning blades
                    const rotationSpeed = 2 + Math.random(); // Varies between turbines
                    
                    // Animation function
                    base.userData = {
                        animate: (delta) => {
                            bladesGroup.rotation.z += rotationSpeed * delta;
                        }
                    };
                }
                
                threeScene.add(base);
                generatorObjects.push(base);
            }
            
            // Transmission lines connecting generators
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
            
            // Connect generators in a ring with some cross connections
            for (let i = 0; i < generatorObjects.length; i++) {
                const gen1 = generatorObjects[i];
                const gen2 = generatorObjects[(i + 1) % generatorObjects.length];
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(gen1.position.x, 1, gen1.position.z),
                    new THREE.Vector3(gen2.position.x, 1, gen2.position.z)
                ]);
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                threeScene.add(line);
                gridLines.push(line);
                
                // Add some cross connections for mesh topology
                if (i % 3 === 0 && i < generatorObjects.length - 2) {
                    const gen3 = generatorObjects[(i + 2) % generatorObjects.length];
                    
                    const crossGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(gen1.position.x, 1, gen1.position.z),
                        new THREE.Vector3(gen3.position.x, 1, gen3.position.z)
                    ]);
                    
                    const crossLine = new THREE.Line(crossGeometry, lineMaterial);
                    threeScene.add(crossLine);
                    gridLines.push(crossLine);
                }
            }
            
            // Add central hub/bus
            const busGeometry = new THREE.CylinderGeometry(1, 1, 0.5, 16);
            const busMaterial = new THREE.MeshStandardMaterial({ color: 0xf39c12 });
            const busBar = new THREE.Mesh(busGeometry, busMaterial);
            busBar.position.set(0, 0.25, 0);
            threeScene.add(busBar);
            
            // Connect all generators to the central bus
            for (let i = 0; i < generatorObjects.length; i++) {
                const gen = generatorObjects[i];
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(gen.position.x, 0.5, gen.position.z),
                    new THREE.Vector3(0, 0.5, 0)
                ]);
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                threeScene.add(line);
                gridLines.push(line);
            }
        }

        function onThreeWindowResize() {
            const container = document.getElementById('three-container');
            if (!container || !threeCamera || !threeRenderer) return;
            
            threeCamera.aspect = container.clientWidth / container.clientHeight;
            threeCamera.updateProjectionMatrix();
            threeRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Apply disturbance to 3D model
        function applyDisturbanceTo3DModel() {
            if (!threeScene) return;
            
            // Stop any previous disturbance animation
            if (disturbanceEffect) {
                cancelAnimationFrame(disturbanceEffect);
            }
            
            // Get parameters
            const inertiaValue = document.getElementById('inertia-3d').value;
            const inertiaFactor = inertiaValue / 100; // 0 to 1
            
            // Create shockwave effect from center
            const shockwaveGeometry = new THREE.RingGeometry(0.2, 0.3, 32);
            const shockwaveMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.rotation.x = -Math.PI / 2;
            shockwave.position.y = 0.1;
            threeScene.add(shockwave);
            
            // Animate the shockwave
            let radius = 0.3;
            let opacity = 0.7;
            
            // Make conventional generators wobble
            generatorObjects.forEach(gen => {
                if (gen.children[0] && gen.children[0].children[0]) {
                    // This is a conventional generator with a rotor
                    gen.userData.originalY = gen.position.y;
                    gen.userData.wobbleStrength = (Math.random() * 0.5 + 0.5) * (1 - inertiaFactor);
                    gen.userData.wobbleFrequency = Math.random() * 5 + 5;
                    gen.userData.wobblePhase = Math.random() * Math.PI * 2;
                    gen.userData.wobbling = true;
                }
            });
            
            const startTime = Date.now();
            
            function animateDisturbance() {
                const elapsed = (Date.now() - startTime) / 1000; // seconds
                
                // Update shockwave
                radius += (10 - radius * 0.5) * 0.05;
                opacity -= 0.01;
                
                shockwave.geometry.dispose();
                shockwave.geometry = new THREE.RingGeometry(radius, radius + 0.3, 32);
                shockwaveMaterial.opacity = opacity;
                
                // Update generator wobble
                generatorObjects.forEach(gen => {
                    if (gen.userData && gen.userData.wobbling) {
                        const strength = gen.userData.wobbleStrength * Math.exp(-elapsed * inertiaFactor);
                        const wobble = Math.sin(elapsed * gen.userData.wobbleFrequency + gen.userData.wobblePhase) * strength;
                        
                        gen.position.y = gen.userData.originalY + wobble;
                        
                        // Stop wobbling when the amplitude gets very small
                        if (strength < 0.01) {
                            gen.userData.wobbling = false;
                            gen.position.y = gen.userData.originalY;
                        }
                    }
                });
                
                // Remove shockwave when it's no longer visible
                if (opacity <= 0) {
                    threeScene.remove(shockwave);
                    shockwaveMaterial.dispose();
                    shockwaveGeometry.dispose();
                    return;
                }
                
                disturbanceEffect = requestAnimationFrame(animateDisturbance);
            }
            
            disturbanceEffect = requestAnimationFrame(animateDisturbance);
        }

        // ======== POWER GRID MAP ========
        let mapContainer, mapSvg, mapWrapper;
        let mapLayers = {};
        let activeMapLayers = ['generation', 'transmission', 'substations'];

        function initializeGridMap() {
            mapContainer = document.getElementById('map-container');
            if (!mapContainer) return;

            // Clear previous map
            mapContainer.innerHTML = '';

            // Create SVG for map
            mapSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            mapSvg.setAttribute('width', '100%');
            mapSvg.setAttribute('height', '100%');
            mapSvg.setAttribute('viewBox', '0 0 1000 600');
            mapContainer.appendChild(mapSvg);

            // Create wrapper for all map elements
            mapWrapper = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mapSvg.appendChild(mapWrapper);

            // Draw base map (Iberian Peninsula simplified outline)
            drawBaseMap();

            // Create layers
            mapLayers.generation = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mapLayers.transmission = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mapLayers.substations = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mapLayers.renewables = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mapLayers.stability = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            // Add layers to map
            Object.values(mapLayers).forEach(layer => {
                mapWrapper.appendChild(layer);
            });

            // Add data to layers
            addGenerationData();
            addTransmissionData();
            addSubstationData();
            addRenewablesData();
            addStabilityData();

            // Setup layer toggles
            const toggleButtons = document.querySelectorAll('.map-layer-toggle');
            toggleButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const layer = button.getAttribute('data-layer');
                    button.classList.toggle('active');
                    
                    if (button.classList.contains('active')) {
                        activeMapLayers.push(layer);
                    } else {
                        activeMapLayers = activeMapLayers.filter(l => l !== layer);
                    }
                    
                    updateMapLayerVisibility();
                });
            });

            // Initial layer visibility
            updateMapLayerVisibility();
        }

        function updateMapLayerVisibility() {
            Object.entries(mapLayers).forEach(([key, layer]) => {
                layer.style.display = activeMapLayers.includes(key) ? 'block' : 'none';
            });
        }

        function drawBaseMap() {
            // Simplified outline of Iberian Peninsula
            const iberianPath = "M250,100 L100,200 L50,350 L100,500 L300,550 L500,500 L700,450 L800,350 L750,200 L600,150 L500,150 L350,100 Z";
            
            // Create base map path
            const baseMap = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            baseMap.setAttribute('d', iberianPath);
            baseMap.setAttribute('fill', '#f0f0f0');
            baseMap.setAttribute('stroke', '#ccc');
            baseMap.setAttribute('stroke-width', '2');
            mapWrapper.appendChild(baseMap);
            
            // Add country border (Spain-Portugal)
            const borderPath = "M300,550 L280,450 L300,350 L275,250 L300,150";
            const border = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            border.setAttribute('d', borderPath);
            border.setAttribute('fill', 'none');
            border.setAttribute('stroke', '#999');
            border.setAttribute('stroke-width', '2');
            border.setAttribute('stroke-dasharray', '5,5');
            mapWrapper.appendChild(border);
            
            // Add labels
            const spainLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            spainLabel.setAttribute('x', '450');
            spainLabel.setAttribute('y', '350');
            spainLabel.setAttribute('font-size', '24');
            spainLabel.setAttribute('fill', '#999');
            spainLabel.setAttribute('text-anchor', 'middle');
            spainLabel.textContent = 'SPAIN';
            mapWrapper.appendChild(spainLabel);
            
            const portugalLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            portugalLabel.setAttribute('x', '175');
            portugalLabel.setAttribute('y', '350');
            portugalLabel.setAttribute('font-size', '18');
            portugalLabel.setAttribute('fill', '#999');
            portugalLabel.setAttribute('text-anchor', 'middle');
            portugalLabel.textContent = 'PORTUGAL';
            mapWrapper.appendChild(portugalLabel);
            
            // Add France connection
            const franceConnector = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            franceConnector.setAttribute('d', 'M750,200 L850,150');
            franceConnector.setAttribute('fill', 'none');
            franceConnector.setAttribute('stroke', '#999');
            franceConnector.setAttribute('stroke-width', '4');
            mapWrapper.appendChild(franceConnector);
            
            const franceLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            franceLabel.setAttribute('x', '870');
            franceLabel.setAttribute('y', '140');
            franceLabel.setAttribute('font-size', '14');
            franceLabel.setAttribute('fill', '#999');
            franceLabel.textContent = 'To France';
            mapWrapper.appendChild(franceLabel);
        }

        function addGenerationData() {
            // Major conventional power plants in Spain and Portugal
            const plants = [
                { type: 'nuclear', name: 'Almaraz Nuclear', x: 350, y: 380, capacity: 2000 },
                { type: 'nuclear', name: 'Cofrentes Nuclear', x: 550, y: 350, capacity: 1100 },
                { type: 'nuclear', name: 'Vandellós II', x: 650, y: 250, capacity: 1000 },
                { type: 'nuclear', name: 'Trillo', x: 480, y: 280, capacity: 1000 },
                { type: 'thermal', name: 'As Pontes', x: 250, y: 170, capacity: 1400 },
                { type: 'thermal', name: 'Sines', x: 150, y: 400, capacity: 1200 },
                { type: 'thermal', name: 'Compostilla', x: 300, y: 200, capacity: 1200 },
                { type: 'thermal', name: 'Pego', x: 200, y: 350, capacity: 600 },
                { type: 'hydro', name: 'Aldeadávila', x: 320, y: 300, capacity: 1200 },
                { type: 'hydro', name: 'Alcántara', x: 320, y: 400, capacity: 900 },
                { type: 'hydro', name: 'Alqueva', x: 240, y: 450, capacity: 500 },
                { type: 'hydro', name: 'José María de Oriol', x: 350, y: 420, capacity: 500 }
            ];
            
            plants.forEach(plant => {
                // Create plant circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', plant.x);
                circle.setAttribute('cy', plant.y);
                circle.setAttribute('r', Math.sqrt(plant.capacity) / 10 + 5); // Size based on capacity
                
                // Color based on type
                let color;
                switch (plant.type) {
                    case 'nuclear':
                        color = '#9b59b6';
                        break;
                    case 'thermal':
                        color = '#e74c3c';
                        break;
                    case 'hydro':
                        color = '#3498db';
                        break;
                    default:
                        color = '#95a5a6';
                }
                
                circle.setAttribute('fill', color);
                circle.setAttribute('stroke', '#333');
                circle.setAttribute('stroke-width', '1');
                
                // Add tooltip on hover
                circle.addEventListener('mouseover', () => {
                    showTooltip(`${plant.name}<br>Type: ${plant.type}<br>Capacity: ${plant.capacity} MW`);
                });
                
                circle.addEventListener('mouseout', hideTooltip);
                
                mapLayers.generation.appendChild(circle);
            });
        }

        function addTransmissionData() {
            // Major transmission lines
            const lines = [
                // Backbone lines
                { from: { x: 250, y: 170 }, to: { x: 300, y: 200 }, voltage: 400 },
                { from: { x: 300, y: 200 }, to: { x: 350, y: 280 }, voltage: 400 },
                { from: { x: 350, y: 280 }, to: { x: 480, y: 280 }, voltage: 400 },
                { from: { x: 480, y: 280 }, to: { x: 550, y: 350 }, voltage: 400 },
                { from: { x: 550, y: 350 }, to: { x: 650, y: 350 }, voltage: 400 },
                { from: { x: 650, y: 350 }, to: { x: 650, y: 250 }, voltage: 400 },
                { from: { x: 650, y: 250 }, to: { x: 750, y: 200 }, voltage: 400 },
                
                // Spain-Portugal interconnections
                { from: { x: 250, y: 170 }, to: { x: 200, y: 200 }, voltage: 400 },
                { from: { x: 320, y: 300 }, to: { x: 250, y: 300 }, voltage: 400 },
                { from: { x: 320, y: 400 }, to: { x: 240, y: 450 }, voltage: 400 },
                
                // Internal Portuguese lines
                { from: { x: 200, y: 200 }, to: { x: 175, y: 300 }, voltage: 400 },
                { from: { x: 175, y: 300 }, to: { x: 150, y: 400 }, voltage: 400 },
                { from: { x: 150, y: 400 }, to: { x: 240, y: 450 }, voltage: 400 },
                
                // Additional Spanish grid
                { from: { x: 350, y: 280 }, to: { x: 350, y: 380 }, voltage: 400 },
                { from: { x: 350, y: 380 }, to: { x: 350, y: 420 }, voltage: 400 },
                { from: { x: 350, y: 420 }, to: { x: 450, y: 450 }, voltage: 400 },
                { from: { x: 450, y: 450 }, to: { x: 550, y: 450 }, voltage: 400 },
                { from: { x: 550, y: 450 }, to: { x: 650, y: 350 }, voltage: 400 },
                
                // France interconnection
                { from: { x: 750, y: 200 }, to: { x: 850, y: 150 }, voltage: 400, isInterconnection: true }
            ];
            
            lines.forEach(line => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                path.setAttribute('x1', line.from.x);
                path.setAttribute('y1', line.from.y);
                path.setAttribute('x2', line.to.x);
                path.setAttribute('y2', line.to.y);
                
                if (line.isInterconnection) {
                    path.setAttribute('stroke', '#f1c40f');
                    path.setAttribute('stroke-width', '6');
                } else if (line.voltage === 400) {
                    path.setAttribute('stroke', '#e74c3c');
                    path.setAttribute('stroke-width', '4');
                } else {
                    path.setAttribute('stroke', '#3498db');
                    path.setAttribute('stroke-width', '2');
                }
                
                // Add tooltip on hover
                path.addEventListener('mouseover', () => {
                    showTooltip(`Transmission Line<br>Voltage: ${line.voltage} kV<br>${line.isInterconnection ? 'Cross-border Interconnection' : 'Domestic Transmission'}`);
                });
                
                path.addEventListener('mouseout', hideTooltip);
                
                mapLayers.transmission.appendChild(path);
            });
        }

        function addSubstationData() {
            // Major substations
            const substations = [
                { name: 'Madrid Substation', x: 470, y: 350 },
                { name: 'Barcelona Substation', x: 700, y: 230 },
                { name: 'Sevilla Substation', x: 400, y: 480 },
                { name: 'Lisbon Substation', x: 150, y: 380 },
                { name: 'Porto Substation', x: 180, y: 250 },
                { name: 'Valencia Substation', x: 600, y: 350 },
                { name: 'Bilbao Substation', x: 450, y: 180 },
                { name: 'Zaragoza Substation', x: 550, y: 250 },
                { name: 'French Interconnection', x: 700, y: 190 },
                { name: 'Northern Portugal Interconnection', x: 230, y: 230 },
                { name: 'Central Portugal Interconnection', x: 280, y: 350 },
                { name: 'Southern Portugal Interconnection', x: 280, y: 450 }
            ];
            
            substations.forEach(substation => {
                // Create substation square
                const square = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                square.setAttribute('x', substation.x - 7);
                square.setAttribute('y', substation.y - 7);
                square.setAttribute('width', 14);
                square.setAttribute('height', 14);
                square.setAttribute('fill', '#34495e');
                square.setAttribute('stroke', '#333');
                square.setAttribute('stroke-width', '1');
                
                // Add tooltip on hover
                square.addEventListener('mouseover', () => {
                    showTooltip(`${substation.name}<br>Major distribution hub`);
                });
                
                square.addEventListener('mouseout', hideTooltip);
                
                mapLayers.substations.appendChild(square);
            });
        }

        function addRenewablesData() {
            // Major renewable energy clusters
            const renewables = [
                { type: 'wind', name: 'Galician Wind Farm Cluster', x: 250, y: 140, capacity: 1500 },
                { type: 'wind', name: 'Aragon Wind Farm Cluster', x: 500, y: 230, capacity: 1800 },
                { type: 'wind', name: 'Navarre Wind Farms', x: 490, y: 180, capacity: 1200 },
                { type: 'wind', name: 'Portuguese Atlantic Wind Farms', x: 130, y: 300, capacity: 800 },
                { type: 'solar', name: 'Extremadura Solar Park', x: 380, y: 420, capacity: 1000 },
                { type: 'solar', name: 'Andalusia Solar Complex', x: 450, y: 500, capacity: 900 },
                { type: 'solar', name: 'Castilla-La Mancha Solar', x: 500, y: 380, capacity: 700 },
                { type: 'solar', name: 'Alentejo Solar Farm', x: 220, y: 420, capacity: 500 }
            ];
            
            renewables.forEach(renewable => {
                let symbol;
                
                if (renewable.type === 'wind') {
                    // Create wind turbine symbol
                    symbol = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    // Turbine tower
                    const tower = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    tower.setAttribute('x', renewable.x - 1);
                    tower.setAttribute('y', renewable.y - 10);
                    tower.setAttribute('width', 2);
                    tower.setAttribute('height', 20);
                    tower.setAttribute('fill', '#7f8c8d');
                    
                    // Turbine blades
                    const blades = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    blades.setAttribute('cx', renewable.x);
                    blades.setAttribute('cy', renewable.y - 10);
                    blades.setAttribute('r', Math.sqrt(renewable.capacity) / 10 + 8);
                    blades.setAttribute('fill', '#2ecc71');
                    blades.setAttribute('fill-opacity', '0.6');
                    blades.setAttribute('stroke', '#27ae60');
                    blades.setAttribute('stroke-width', '1');
                    
                    symbol.appendChild(blades);
                    symbol.appendChild(tower);
                } else {
                    // Create solar panel symbol
                    symbol = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    symbol.setAttribute('x', renewable.x - (Math.sqrt(renewable.capacity) / 10 + 5));
                    symbol.setAttribute('y', renewable.y - (Math.sqrt(renewable.capacity) / 10 + 5));
                    symbol.setAttribute('width', (Math.sqrt(renewable.capacity) / 10 + 5) * 2);
                    symbol.setAttribute('height', (Math.sqrt(renewable.capacity) / 10 + 5) * 2);
                    symbol.setAttribute('fill', '#f1c40f');
                    symbol.setAttribute('fill-opacity', '0.6');
                    symbol.setAttribute('stroke', '#f39c12');
                    symbol.setAttribute('stroke-width', '1');
                }
                
                // Add tooltip on hover
                symbol.addEventListener('mouseover', () => {
                    showTooltip(`${renewable.name}<br>Type: ${renewable.type}<br>Capacity: ${renewable.capacity} MW`);
                });
                
                symbol.addEventListener('mouseout', hideTooltip);
                
                mapLayers.renewables.appendChild(symbol);
            });
        }
function addStabilityData() {
            // Example stability risk data (areas with higher risk)
            const riskAreas = [
                { name: 'Northern Corridor', x: 400, y: 180, radius: 80, risk: 'High', details: 'High renewable variability, potential congestion.' },
                { name: 'Southern Interconnection', x: 300, y: 480, radius: 60, risk: 'Medium', details: 'Dependency on specific lines, some aging infrastructure.' },
                { name: 'Eastern Coastal Area', x: 680, y: 300, radius: 70, risk: 'Medium', details: 'High demand, some exposure to extreme weather.' }
            ];

            riskAreas.forEach(area => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', area.x);
                circle.setAttribute('cy', area.y);
                circle.setAttribute('r', area.radius);
                
                let color, opacity;
                if (area.risk === 'High') {
                    color = 'var(--danger)'; // Red
                    opacity = 0.3;
                } else if (area.risk === 'Medium') {
                    color = 'var(--warning)'; // Orange
                    opacity = 0.3;
                } else {
                    color = 'var(--success)'; // Green
                    opacity = 0.2;
                }
                
                circle.setAttribute('fill', color);
                circle.setAttribute('fill-opacity', opacity);
                circle.setAttribute('stroke', color);
                circle.setAttribute('stroke-width', '1');
                circle.setAttribute('stroke-dasharray', '5,5');

                circle.addEventListener('mouseover', () => {
                    showTooltip(`Stability Risk: ${area.name}<br>Level: ${area.risk}<br>Details: ${area.details}`);
                });
                circle.addEventListener('mouseout', hideTooltip);
                
                mapLayers.stability.appendChild(circle);
            });
        }

        // ======== BLACKOUT CASCADE SIMULATION ========
        let cascadeSvg, cascadeNodes = [], cascadeLines = [], cascadeInterval, cascadeTime = 0;
        let cascadeRunning = false;
        const cascadeLoading = document.getElementById('cascade-loading');
        const runCascadeBtn = document.getElementById('run-cascade');
        const pauseCascadeBtn = document.getElementById('pause-cascade');
        const restartCascadeBtn = document.getElementById('restart-cascade');
        const cascadeTimeDisplay = document.getElementById('cascade-time');

        function initializeCascadeSimulation() {
            const container = document.getElementById('cascade-container');
            if (!container) return;
            container.innerHTML = ''; // Clear previous

            cascadeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            cascadeSvg.setAttribute('width', '100%');
            cascadeSvg.setAttribute('height', '100%');
            cascadeSvg.setAttribute('viewBox', '0 0 600 400');
            container.appendChild(cascadeSvg);

            setupCascadeGrid();
            drawCascadeGrid();

            runCascadeBtn.onclick = () => {
                if (cascadeRunning) return;
                cascadeLoading.style.display = 'flex';
                runCascadeBtn.disabled = true;
                pauseCascadeBtn.disabled = false;
                restartCascadeBtn.disabled = false;
                
                setTimeout(() => {
                    startCascade();
                    cascadeLoading.style.display = 'none';
                }, 500);
            };

            pauseCascadeBtn.onclick = () => {
                if (!cascadeRunning) return;
                clearInterval(cascadeInterval);
                cascadeRunning = false;
                pauseCascadeBtn.textContent = '▶ Resume';
                pauseCascadeBtn.onclick = () => resumeCascade();
            };
            
            restartCascadeBtn.onclick = () => {
                resetCascade();
                pauseCascadeBtn.textContent = '⏸ Pause';
                pauseCascadeBtn.disabled = true;
                restartCascadeBtn.disabled = true;
                runCascadeBtn.disabled = false;
            };
            resetCascade(); // Initial state
        }
        
        function resumeCascade() {
            if (cascadeRunning) return;
            cascadeRunning = true;
            pauseCascadeBtn.textContent = '⏸ Pause';
            pauseCascadeBtn.onclick = () => { // Re-assign original pause behavior
                if (!cascadeRunning) return;
                clearInterval(cascadeInterval);
                cascadeRunning = false;
                pauseCascadeBtn.textContent = '▶ Resume';
                pauseCascadeBtn.onclick = () => resumeCascade();
            };
            cascadeInterval = setInterval(simulateCascadeStep, 1000);
        }


        function setupCascadeGrid() {
            cascadeNodes = [];
            cascadeLines = [];
            const numRows = 5;
            const numCols = 7;
            const spacingX = 600 / (numCols + 1);
            const spacingY = 400 / (numRows + 1);

            for (let r = 0; r < numRows; r++) {
                for (let c = 0; c < numCols; c++) {
                    const type = Math.random() > 0.8 ? 'generator' : (Math.random() > 0.6 ? 'substation' : 'load');
                    cascadeNodes.push({
                        id: `n-${r}-${c}`,
                        x: spacingX * (c + 1),
                        y: spacingY * (r + 1),
                        type: type,
                        status: 'ok', // ok, overloaded, failed
                        load: type === 'load' ? Math.random() * 50 + 50 : 0,
                        generation: type === 'generator' ? Math.random() * 100 + 100 : 0,
                        maxCapacity: type === 'generator' ? 200 : (type === 'substation' ? 300 : 100)
                    });
                }
            }

            // Connect nodes (simple grid connections)
            for (let r = 0; r < numRows; r++) {
                for (let c = 0; c < numCols; c++) {
                    const FONT_STYLES = {};
                    const nodeIndex = r * numCols + c;
                    if (c < numCols - 1) { // Connect to right neighbor
                        cascadeLines.push({ from: nodeIndex, to: nodeIndex + 1, status: 'ok', capacity: 150, flow: 0 });
                    }
                    if (r < numRows - 1) { // Connect to bottom neighbor
                        cascadeLines.push({ from: nodeIndex, to: nodeIndex + numCols, status: 'ok', capacity: 150, flow: 0 });
                    }
                }
            }
        }

        function drawCascadeGrid() {
            cascadeSvg.innerHTML = ''; // Clear SVG

            cascadeLines.forEach(line => {
                const fromNode = cascadeNodes[line.from];
                const toNode = cascadeNodes[line.to];
                const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                l.setAttribute('x1', fromNode.x);
                l.setAttribute('y1', fromNode.y);
                l.setAttribute('x2', toNode.x);
                l.setAttribute('y2', toNode.y);
                let strokeColor = 'var(--secondary)';
                if (line.status === 'overloaded') strokeColor = 'var(--warning)';
                if (line.status === 'failed') strokeColor = 'var(--danger)';
                l.setAttribute('stroke', strokeColor);
                l.setAttribute('stroke-width', '3');
                cascadeSvg.appendChild(l);
            });

            cascadeNodes.forEach(node => {
                const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                c.setAttribute('cx', node.x);
                c.setAttribute('cy', node.y);
                c.setAttribute('r', node.type === 'generator' ? '12' : (node.type === 'substation' ? '10' : '8'));
                let fillColor = 'var(--primary)';
                if (node.type === 'generator') fillColor = 'var(--success)';
                if (node.type === 'load') fillColor = 'var(--accent)';
                if (node.status === 'overloaded') fillColor = 'var(--warning)';
                if (node.status === 'failed') fillColor = 'var(--danger)';
                c.setAttribute('fill', fillColor);
                c.setAttribute('stroke', '#333');
                c.setAttribute('stroke-width', '1.5');
                
                c.addEventListener('mouseover', () => showTooltip(`Node: ${node.id}<br>Type: ${node.type}<br>Status: ${node.status}<br>Load: ${node.load.toFixed(0)}<br>Gen: ${node.generation.toFixed(0)}`));
                c.addEventListener('mouseout', hideTooltip);
                cascadeSvg.appendChild(c);
            });
        }

        function startCascade() {
            resetCascade();
            cascadeRunning = true;
            
            // Apply initial fault based on selection
            const faultType = document.getElementById('initial-fault').value;
            const systemLoadingFactor = parseInt(document.getElementById('system-loading').value) / 100;

            cascadeNodes.forEach(n => {
                if (n.type === 'load') n.load *= systemLoadingFactor;
                if (n.type === 'generator') n.generation *= systemLoadingFactor; // Scale generation too
            });

            if (faultType === 'line-trip' && cascadeLines.length > 0) {
                const randomLineIndex = Math.floor(Math.random() * cascadeLines.length);
                cascadeLines[randomLineIndex].status = 'failed';
            } else if (faultType === 'generator-loss') {
                const generators = cascadeNodes.filter(n => n.type === 'generator');
                if (generators.length > 0) {
                    generators[Math.floor(Math.random() * generators.length)].status = 'failed';
                }
            }
            // Other fault types can be added here

            drawCascadeGrid();
            cascadeInterval = setInterval(simulateCascadeStep, 1000); // Simulate every second
        }

        function simulateCascadeStep() {
            cascadeTime++;
            cascadeTimeDisplay.textContent = `Time: ${cascadeTime}s`;
            let changesMade = false;

            // Simple power flow and overload logic
            // Reset flows
            cascadeLines.forEach(l => l.flow = 0);
            cascadeNodes.forEach(n => {
                if (n.status === 'failed') {
                    n.generation = 0;
                    n.load = 0; // No load if node failed
                }
            });

            // Very basic "flow" distribution - this is not a real power flow
            for (let i = 0; i < 5; i++) { // Iterative "distribution"
                cascadeNodes.forEach(node => {
                    if (node.status !== 'ok') return;
                    let imbalance = node.generation - node.load;
                    const connectedLines = cascadeLines.filter(l => (l.from === cascadeNodes.indexOf(node) || l.to === cascadeNodes.indexOf(node)) && l.status === 'ok');
                    
                    if (connectedLines.length > 0) {
                        let share = imbalance / connectedLines.length;
                        connectedLines.forEach(line => {
                            if (line.from === cascadeNodes.indexOf(node)) line.flow += share;
                            else line.flow -= share; // Flow direction
                        });
                    }
                });
            }
            
            // Check line overloads
            cascadeLines.forEach(line => {
                if (line.status === 'ok' && Math.abs(line.flow) > line.capacity) {
                    line.status = 'overloaded';
                    changesMade = true;
                    // Simple cascading: if overloaded for a tick, it fails
                    setTimeout(() => { if(line.status === 'overloaded') line.status = 'failed'; drawCascadeGrid(); }, 500);
                }
            });

            // Check node overloads (e.g. substations)
            cascadeNodes.forEach(node => {
                if (node.status === 'ok') {
                    let incidentFlow = 0;
                    cascadeLines.forEach(l => {
                        if (l.status === 'ok' && (l.from === cascadeNodes.indexOf(node) || l.to === cascadeNodes.indexOf(node))) {
                            incidentFlow += Math.abs(l.flow);
                        }
                    });
                    if (node.type === 'substation' && incidentFlow / 2 > node.maxCapacity) { // incidentFlow is double counted
                        node.status = 'overloaded';
                        changesMade = true;
                        setTimeout(() => { if(node.status === 'overloaded') node.status = 'failed'; drawCascadeGrid(); }, 500);
                    }
                }
            });
            
            // If a generator fails, its generation goes to 0.
            // If a load node fails, its load goes to 0.
            // This will cause imbalances picked up in the next iteration.

            drawCascadeGrid();

            // Stop if no changes or max time
            if (!changesMade && cascadeTime > 10 || cascadeTime > 60) {
                 //clearInterval(cascadeInterval);
                 //cascadeRunning = false;
                 // console.log("Cascade stabilized or max time reached.");
            }
            const activeNodes = cascadeNodes.filter(n => n.status !== 'failed' && n.type === 'load').length;
            if (activeNodes === 0 && cascadeTime > 1) { // All loads failed
                clearInterval(cascadeInterval);
                cascadeRunning = false;
                console.log("Total blackout.");
            }
        }

        function resetCascade() {
            clearInterval(cascadeInterval);
            cascadeTime = 0;
            cascadeRunning = false;
            cascadeTimeDisplay.textContent = 'Time: 0s';
            setupCascadeGrid(); // Re-initialize nodes and lines
            drawCascadeGrid();
            runCascadeBtn.disabled = false;
            pauseCascadeBtn.disabled = true;
            pauseCascadeBtn.textContent = '⏸ Pause';
            restartCascadeBtn.disabled = true;
        }


        // ======== RENEWABLE TRANSITION ========
        let transitionSvg;
        const transitionLoading = document.getElementById('transition-loading');
        const updateTransitionBtn = document.getElementById('update-transition');

        function initializeRenewableTransition() {
            const container = document.getElementById('transition-container');
            if (!container) return;
            container.innerHTML = '';

            transitionSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            transitionSvg.setAttribute('width', '100%');
            transitionSvg.setAttribute('height', '100%');
            transitionSvg.setAttribute('viewBox', '0 0 800 400');
            container.appendChild(transitionSvg);
            
            updateTransitionBtn.onclick = () => {
                transitionLoading.style.display = 'flex';
                updateTransitionBtn.disabled = true;
                setTimeout(() => {
                    renderRenewableTransitionChart();
                    transitionLoading.style.display = 'none';
                    updateTransitionBtn.disabled = false;
                }, 500);
            };
            renderRenewableTransitionChart(); // Initial render
        }

        function getRenewableTransitionData(year, scenario, region) {
            // Mock data - in a real app, this would come from a model or API
            const baseData = {
                '2020': { renewablePenetration: 20, systemInertia: 12000, stabilityIndex: 85 },
                '2025': { renewablePenetration: 35, systemInertia: 10000, stabilityIndex: 75 },
                '2030': { renewablePenetration: 50, systemInertia: 8000, stabilityIndex: 60 },
                '2035': { renewablePenetration: 65, systemInertia: 6500, stabilityIndex: 50 },
                '2040': { renewablePenetration: 75, systemInertia: 5000, stabilityIndex: 40 },
                '2045': { renewablePenetration: 85, systemInertia: 4000, stabilityIndex: 35 },
                '2050': { renewablePenetration: 90, systemInertia: 3500, stabilityIndex: 30 }
            };

            let data = JSON.parse(JSON.stringify(baseData[year])); // Get data for the selected year

            // Adjust based on scenario
            if (scenario === 'accelerated') {
                data.renewablePenetration = Math.min(100, data.renewablePenetration * 1.2);
                data.systemInertia *= 0.8;
                data.stabilityIndex *= 0.85;
            } else if (scenario === 'gfm') {
                data.stabilityIndex *= 1.15; // GFM improves stability
                data.systemInertia *= 1.05; // GFM can provide synthetic inertia
            } else if (scenario === 'storage') {
                data.stabilityIndex *= 1.1; // Storage helps stability
            }

            // Adjust based on region (very simplified)
            if (region === 'europe') {
                data.systemInertia *= 1.1; // Europe has larger interconnected grid
            } else if (region === 'australia') {
                data.systemInertia *= 0.8; // Australia has more isolated grids
                data.renewablePenetration = Math.min(100, data.renewablePenetration * 1.1); // Higher renewable uptake
            }
            
            // Ensure values are within reasonable bounds
            data.renewablePenetration = Math.max(0, Math.min(100, data.renewablePenetration));
            data.systemInertia = Math.max(1000, data.systemInertia);
            data.stabilityIndex = Math.max(0, Math.min(100, data.stabilityIndex));

            return data;
        }

        function renderRenewableTransitionChart() {
            transitionSvg.innerHTML = ''; // Clear SVG

            const year = document.getElementById('year-slider').value;
            const scenario = document.getElementById('scenario').value;
            const region = document.getElementById('region').value;
            
            const data = getRenewableTransitionData(year, scenario, region);

            const chartWidth = 700;
            const chartHeight = 300;
            const margin = { top: 30, right: 150, bottom: 50, left: 60 }; // Increased right margin for legend

            // Create axes (similar to frequency chart)
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', margin.left);
            xAxis.setAttribute('y1', margin.top + chartHeight);
            xAxis.setAttribute('x2', margin.left + chartWidth);
            xAxis.setAttribute('y2', margin.top + chartHeight);
            xAxis.setAttribute('stroke', '#333');
            transitionSvg.appendChild(xAxis);

            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', margin.left);
            yAxis.setAttribute('y1', margin.top);
            yAxis.setAttribute('x2', margin.left);
            yAxis.setAttribute('y2', margin.top + chartHeight);
            yAxis.setAttribute('stroke', '#333');
            transitionSvg.appendChild(yAxis);
            
            // Title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', (margin.left + chartWidth / 2));
            title.setAttribute('y', margin.top - 5);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '16');
            title.setAttribute('font-weight', 'bold');
            title.textContent = `Grid Impact in ${year} (${scenario}, ${region})`;
            transitionSvg.appendChild(title);

            // Y-axis labels (0-100 for penetration/stability, 0-15000 for inertia)
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + chartHeight - (i * chartHeight / 10);
                const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                tickLabel.setAttribute('x', margin.left - 10);
                tickLabel.setAttribute('y', y + 4);
                tickLabel.setAttribute('text-anchor', 'end');
                tickLabel.setAttribute('font-size', '10');
                tickLabel.textContent = i * 10; // For % and stability index
                transitionSvg.appendChild(tickLabel);

                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', margin.left);
                gridLine.setAttribute('y1', y);
                gridLine.setAttribute('x2', margin.left + chartWidth);
                gridLine.setAttribute('y2', y);
                gridLine.setAttribute('stroke', '#e0e0e0');
                gridLine.setAttribute('stroke-dasharray', '2,2');
                transitionSvg.appendChild(gridLine);
            }
            
            // Bars for data
            const barWidth = chartWidth / 5; // 3 bars + spacing
            const categories = ['Renewable %', 'System Inertia (GW·s)', 'Stability Index'];
            const colors = ['var(--success)', 'var(--primary)', 'var(--warning)'];
            const values = [data.renewablePenetration, data.systemInertia, data.stabilityIndex];
            const maxValues = [100, 15000, 100]; // Max values for scaling bars

            categories.forEach((cat, i) => {
                const barHeight = (values[i] / maxValues[i]) * chartHeight;
                const barX = margin.left + barWidth * (i + 0.5) + i * barWidth/2;

                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('x', barX);
                bar.setAttribute('y', margin.top + chartHeight - barHeight);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', colors[i]);
                
                // Animate bar height
                bar.setAttribute('height', '0');
                bar.setAttribute('y', margin.top + chartHeight);
                anime({
                    targets: bar,
                    height: [0, barHeight],
                    y: [margin.top + chartHeight, margin.top + chartHeight - barHeight],
                    duration: 1000,
                    delay: i * 200,
                    easing: 'easeOutExpo'
                });
                transitionSvg.appendChild(bar);

                // Bar value label
                const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                valueLabel.setAttribute('x', barX + barWidth / 2);
                valueLabel.setAttribute('y', margin.top + chartHeight - barHeight - 5);
                valueLabel.setAttribute('text-anchor', 'middle');
                valueLabel.setAttribute('font-size', '12');
                valueLabel.setAttribute('fill', '#333');
                valueLabel.textContent = values[i].toFixed(0) + (i === 0 || i === 2 ? '%' : (i === 1 ? ' GW·s' : ''));
                valueLabel.style.opacity = 0;
                 anime({
                    targets: valueLabel,
                    opacity: [0,1],
                    translateY: [10,0],
                    duration: 500,
                    delay: 1000 + i * 200,
                    easing: 'easeOutQuad'
                });
                transitionSvg.appendChild(valueLabel);

                // Category label
                const catLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                catLabel.setAttribute('x', barX + barWidth / 2);
                catLabel.setAttribute('y', margin.top + chartHeight + 20);
                catLabel.setAttribute('text-anchor', 'middle');
                catLabel.setAttribute('font-size', '12');
                catLabel.textContent = cat;
                transitionSvg.appendChild(catLabel);
            });
            
            // Legend
            const legendX = margin.left + chartWidth + 20;
            categories.forEach((cat, i) => {
                const legendItem = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const legendColor = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                legendColor.setAttribute('x', legendX);
                legendColor.setAttribute('y', margin.top + i * 25);
                legendColor.setAttribute('width', 15);
                legendColor.setAttribute('height', 15);
                legendColor.setAttribute('fill', colors[i]);
                legendItem.appendChild(legendColor);
                
                const legendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                legendText.setAttribute('x', legendX + 25);
                legendText.setAttribute('y', margin.top + i * 25 + 12);
                legendText.setAttribute('font-size', '12');
                legendText.textContent = cat;
                legendItem.appendChild(legendText);
                
                transitionSvg.appendChild(legendItem);
            });
        }