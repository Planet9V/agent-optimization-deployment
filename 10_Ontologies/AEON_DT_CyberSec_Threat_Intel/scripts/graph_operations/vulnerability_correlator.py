#!/usr/bin/env python3
"""
Vulnerability Correlator - Match CVEs to assets using CPE and software versions
"""

import re
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from packaging import version
from neo4j import GraphDatabase
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityMatch:
    """Represents a CVE-to-asset correlation"""
    cve_id: str
    asset_name: str
    software_name: str
    installed_version: str
    vulnerable_versions: List[str]
    confidence: float
    match_type: str  # exact/range/pattern
    cvss_score: float
    transitive: bool = False  # From dependency chain


class VulnerabilityCorrelator:
    """Correlate vulnerabilities to assets based on CPE and versions"""

    def __init__(self, uri: str, user: str, password: str):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def correlate_asset(self, asset_name: str) -> List[VulnerabilityMatch]:
        """Find all vulnerabilities affecting an asset"""
        query = '''
        MATCH (asset:Component {name: $asset_name})
        OPTIONAL MATCH (asset)-[:RUNS]->(software:Software)
        OPTIONAL MATCH (software)-[:HAS_VERSION]->(ver:Version)
        WITH asset, software, ver
        OPTIONAL MATCH (vuln:Vulnerability)-[:AFFECTS]->(cpe:CPE)
        WHERE
            cpe.vendor = software.vendor AND
            cpe.product = software.product
        RETURN
            asset.name as asset,
            software.name as software,
            software.vendor as vendor,
            software.product as product,
            ver.number as version,
            COLLECT(DISTINCT {
                cve: vuln.id,
                cvss: vuln.cvss_score,
                vulnerable_versions: vuln.vulnerable_versions,
                cpe_match: cpe.criteria
            }) as vulnerabilities
        '''

        with self.driver.session() as session:
            result = session.run(query, asset_name=asset_name)

            matches = []
            for record in result:
                installed_version = record["version"]
                software_name = record["software"]

                for vuln in record["vulnerabilities"]:
                    if not vuln["cve"]:
                        continue

                    # Check version matching
                    is_vulnerable, confidence, match_type = self._check_version_match(
                        installed_version,
                        vuln["vulnerable_versions"]
                    )

                    if is_vulnerable:
                        match = VulnerabilityMatch(
                            cve_id=vuln["cve"],
                            asset_name=asset_name,
                            software_name=software_name,
                            installed_version=installed_version,
                            vulnerable_versions=vuln["vulnerable_versions"],
                            confidence=confidence,
                            match_type=match_type,
                            cvss_score=float(vuln["cvss"] or 0.0),
                            transitive=False
                        )
                        matches.append(match)

            logger.info(f"Found {len(matches)} vulnerability matches for {asset_name}")
            return matches

    def correlate_by_cpe(self, cpe_string: str) -> List[VulnerabilityMatch]:
        """Find vulnerabilities matching a CPE string"""
        # Parse CPE: cpe:2.3:a:vendor:product:version:...
        cpe_parts = cpe_string.split(":")
        if len(cpe_parts) < 5:
            logger.error(f"Invalid CPE format: {cpe_string}")
            return []

        vendor = cpe_parts[3]
        product = cpe_parts[4]
        cpe_version = cpe_parts[5] if len(cpe_parts) > 5 else "*"

        query = '''
        MATCH (vuln:Vulnerability)-[:AFFECTS]->(cpe:CPE)
        WHERE
            cpe.vendor = $vendor AND
            cpe.product = $product
        OPTIONAL MATCH (asset:Component)-[:RUNS]->(software:Software)
        WHERE
            software.vendor = $vendor AND
            software.product = $product
        RETURN
            vuln.id as cve,
            vuln.cvss_score as cvss,
            vuln.vulnerable_versions as vulnerable_versions,
            COLLECT(DISTINCT asset.name) as affected_assets
        '''

        with self.driver.session() as session:
            result = session.run(query, vendor=vendor, product=product)

            matches = []
            for record in result:
                vulnerable_versions = record["vulnerable_versions"] or []

                # Check version match
                is_vulnerable, confidence, match_type = self._check_version_match(
                    cpe_version,
                    vulnerable_versions
                )

                if is_vulnerable:
                    for asset in record["affected_assets"]:
                        match = VulnerabilityMatch(
                            cve_id=record["cve"],
                            asset_name=asset,
                            software_name=f"{vendor}:{product}",
                            installed_version=cpe_version,
                            vulnerable_versions=vulnerable_versions,
                            confidence=confidence,
                            match_type=match_type,
                            cvss_score=float(record["cvss"] or 0.0)
                        )
                        matches.append(match)

            return matches

    def find_transitive_vulnerabilities(
        self,
        asset_name: str,
        max_depth: int = 3
    ) -> List[VulnerabilityMatch]:
        """Find vulnerabilities in dependencies (transitive)"""
        query = f'''
        MATCH (asset:Component {{name: $asset_name}})
        MATCH path = (asset)-[:DEPENDS_ON*1..{max_depth}]->(dep:Component)
        MATCH (dep)-[:RUNS]->(software:Software)
        MATCH (vuln:Vulnerability)-[:AFFECTS]->(software)
        WITH asset, dep, software, vuln, length(path) as depth
        RETURN
            asset.name as asset,
            dep.name as dependency,
            software.name as software,
            vuln.id as cve,
            vuln.cvss_score as cvss,
            depth
        ORDER BY depth ASC
        '''

        with self.driver.session() as session:
            result = session.run(query, asset_name=asset_name)

            matches = []
            for record in result:
                match = VulnerabilityMatch(
                    cve_id=record["cve"],
                    asset_name=record["asset"],
                    software_name=f"{record['software']} (via {record['dependency']})",
                    installed_version="unknown",
                    vulnerable_versions=[],
                    confidence=0.8 - (record["depth"] * 0.1),  # Lower confidence for deeper deps
                    match_type="transitive",
                    cvss_score=float(record["cvss"] or 0.0),
                    transitive=True
                )
                matches.append(match)

            logger.info(f"Found {len(matches)} transitive vulnerabilities for {asset_name}")
            return matches

    def batch_correlate(
        self,
        asset_names: List[str]
    ) -> Dict[str, List[VulnerabilityMatch]]:
        """Batch correlate multiple assets"""
        results = {}

        for asset in asset_names:
            matches = self.correlate_asset(asset)
            if matches:
                results[asset] = matches

        return results

    def correlate_sbom(self, sbom_data: Dict) -> List[VulnerabilityMatch]:
        """
        Correlate vulnerabilities from SBOM (Software Bill of Materials)

        SBOM format expected:
        {
            "components": [
                {
                    "name": "openssl",
                    "version": "1.1.1k",
                    "vendor": "openssl",
                    "cpe": "cpe:2.3:a:openssl:openssl:1.1.1k:*:*:*:*:*:*:*"
                }
            ]
        }
        """
        matches = []

        for component in sbom_data.get("components", []):
            cpe = component.get("cpe")
            if cpe:
                component_matches = self.correlate_by_cpe(cpe)
                matches.extend(component_matches)

        logger.info(f"SBOM correlation found {len(matches)} vulnerabilities")
        return matches

    def _check_version_match(
        self,
        installed: str,
        vulnerable_versions: List[str]
    ) -> Tuple[bool, float, str]:
        """
        Check if installed version matches vulnerable versions

        Returns: (is_vulnerable, confidence, match_type)
        """
        if not installed or installed == "*" or not vulnerable_versions:
            return True, 0.5, "pattern"  # Unknown version = potential match

        # Clean version string
        installed_clean = self._clean_version(installed)

        for vuln_spec in vulnerable_versions:
            # Exact match
            if installed_clean == vuln_spec:
                return True, 1.0, "exact"

            # Range match (e.g., ">=1.0.0,<2.0.0")
            if self._check_version_range(installed_clean, vuln_spec):
                return True, 0.9, "range"

            # Pattern match (e.g., "1.1.*")
            if self._check_version_pattern(installed_clean, vuln_spec):
                return True, 0.7, "pattern"

        return False, 0.0, "none"

    def _clean_version(self, ver: str) -> str:
        """Clean and normalize version string"""
        # Remove 'v' prefix
        ver = ver.lstrip('v')
        # Remove build metadata
        ver = re.sub(r'\+.*$', '', ver)
        return ver

    def _check_version_range(self, installed: str, range_spec: str) -> bool:
        """Check if version falls within range"""
        try:
            # Parse range specifications like ">=1.0.0,<2.0.0"
            conditions = range_spec.split(',')
            installed_ver = version.parse(installed)

            for condition in conditions:
                condition = condition.strip()

                if condition.startswith(">="):
                    min_ver = version.parse(condition[2:])
                    if installed_ver < min_ver:
                        return False
                elif condition.startswith(">"):
                    min_ver = version.parse(condition[1:])
                    if installed_ver <= min_ver:
                        return False
                elif condition.startswith("<="):
                    max_ver = version.parse(condition[2:])
                    if installed_ver > max_ver:
                        return False
                elif condition.startswith("<"):
                    max_ver = version.parse(condition[1:])
                    if installed_ver >= max_ver:
                        return False
                elif condition.startswith("=="):
                    target_ver = version.parse(condition[2:])
                    if installed_ver != target_ver:
                        return False

            return True
        except:
            return False

    def _check_version_pattern(self, installed: str, pattern: str) -> bool:
        """Check if version matches wildcard pattern"""
        # Convert pattern to regex
        regex_pattern = pattern.replace(".", r"\.").replace("*", r".*")
        regex_pattern = f"^{regex_pattern}$"

        return bool(re.match(regex_pattern, installed))

    def generate_correlation_report(
        self,
        matches: List[VulnerabilityMatch]
    ) -> Dict:
        """Generate vulnerability correlation report"""
        # Group by asset
        by_asset = {}
        for match in matches:
            if match.asset_name not in by_asset:
                by_asset[match.asset_name] = []
            by_asset[match.asset_name].append(match)

        # Calculate statistics
        total_cves = len(set(m.cve_id for m in matches))
        high_confidence = [m for m in matches if m.confidence >= 0.9]
        critical_cvss = [m for m in matches if m.cvss_score >= 9.0]
        transitive = [m for m in matches if m.transitive]

        report = {
            "summary": {
                "total_matches": len(matches),
                "unique_cves": total_cves,
                "affected_assets": len(by_asset),
                "high_confidence": len(high_confidence),
                "critical_cvss": len(critical_cvss),
                "transitive_deps": len(transitive)
            },
            "by_asset": {
                asset: {
                    "total_vulnerabilities": len(asset_matches),
                    "critical_count": sum(1 for m in asset_matches if m.cvss_score >= 9.0),
                    "high_count": sum(1 for m in asset_matches if m.cvss_score >= 7.0),
                    "avg_confidence": sum(m.confidence for m in asset_matches) / len(asset_matches),
                    "vulnerabilities": [
                        {
                            "cve": m.cve_id,
                            "cvss": m.cvss_score,
                            "software": m.software_name,
                            "version": m.installed_version,
                            "confidence": m.confidence,
                            "transitive": m.transitive
                        }
                        for m in sorted(asset_matches, key=lambda x: x.cvss_score, reverse=True)[:10]
                    ]
                }
                for asset, asset_matches in by_asset.items()
            }
        }

        return report


def main():
    """Example usage"""
    correlator = VulnerabilityCorrelator(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="password"
    )

    try:
        # Correlate single asset
        matches = correlator.correlate_asset("web-server-1")
        print(f"Found {len(matches)} vulnerabilities for web-server-1")

        for match in matches[:5]:
            print(f"\n{match.cve_id}:")
            print(f"  Software: {match.software_name} v{match.installed_version}")
            print(f"  CVSS: {match.cvss_score}")
            print(f"  Confidence: {match.confidence:.2f}")
            print(f"  Match Type: {match.match_type}")

        # Find transitive vulnerabilities
        transitive = correlator.find_transitive_vulnerabilities("web-server-1")
        print(f"\nFound {len(transitive)} transitive vulnerabilities")

        # Generate report
        report = correlator.generate_correlation_report(matches)
        print(f"\nSummary:")
        print(f"  Unique CVEs: {report['summary']['unique_cves']}")
        print(f"  High Confidence: {report['summary']['high_confidence']}")
        print(f"  Critical: {report['summary']['critical_cvss']}")

    finally:
        correlator.close()


if __name__ == "__main__":
    main()
